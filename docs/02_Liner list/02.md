# 1. 线性表(linear list，简称list)

### 定义

线性表是$n(n≥0)$​个相同类型的数据元素构成的**有限序列**。 

> 有限序列：
>
> 1. 有且只有一个“第一个”元素
> 2. 有且只有一个“最后一个”元素
> 3. 元素都有唯一的**前驱**和**后继**，（除了首尾元素）
>
> c语言中的数组，就是一个典型的线性表

#### 数学表示

- $(a_1，a_2，…，a_n)$ （形似数列）

- 其中，$n$为线性表的长度，当 $n=0$时，表示线性表是一个空表，即表中不包含任何元素。

- 对任意一对相邻元素$<a_i,a_{i+1}>(1≤i<n)$，$a_i$ 称为$a_{i+1}$ 的**前驱 ．**$a_{i+1}$称为$a_i$​ 的**后继**


#### 逻辑视图

![](./02_assest/im_1.jpg)

### 基本操作

> 我们知道，一个**数据类型**，不只要有相应的数据元素，还需要对该元素的操作

线性表的基本操作通常包括：

- **初始化**：创建一个空表。
- **销毁**：释放线性表所占用的内存空间。
- **插入**：在指定位置插入一个元素。
- **删除**：删除指定位置的元素。
- **查找**：查找给定值的元素并返回其位置。
- **遍历**：遍历表中的每一个元素，进行操作。

#### 注意事项

- 线性表除第一个和最后一个元素之外，每一格数据元素只有**一个前驱和一个后继**
- 元素含义无所谓，可以指任何东西，但**元素类型必须相同**

# 2. 顺序表

#### 定义

顺序存储结构：用一组地址连续的存储单元依次存储**数据结构**(在这里是线性表)里各个元素，这种存储结构称为线性表的顺序存储结构。

> 拓展：数据的存储结构
>
> 1. 顺序存储 ： 物理位置上相邻
> 2. 链式存储 ： 不要求物理位置上相邻
> 3. 索引存储
> 4. 散列存储

## 表示

在c语言中，我们一般用**数组**来表示顺序表

*数组（array）*是一种**典型的**线性数据结构，是一种**典型的顺序表。**

```c
/* 初始化数组 */
int arr[5] = { 0 }; // { 0, 0, 0, 0, 0 }
int nums[5] = { 1, 3, 2, 5, 4 };
```

#### 逻辑图示

![1.jpg](./02_assest/im_2.jpg)

在计算机中，数组的分配形式是连贯的：

![](./02_assest/im_3.png)

#### 注意事项

访问顺序表中任意元素的时间都相等，具有这一特点的存储结构称为**随机存取结构**。

> 注意 ：这里是"存取"结构，和上文的“存储”结构并不相同，读者可忽略相关专有名词，只需注意数组访问各个元素的时间复杂度是 $O(1)$ 即可。

**也就是说，在顺序表中，我们访问第 $i$ 个元素时，不需要遍历前 $i - 1$个元素，而是可以直接访问第 $i$个元素，**

比如在数组$<1，2，3，4，5，7，8，9>$中，若我们要访问 $a_4$（也就是 $5$ 这个元素）我们可以根据据数组首地址 $a_0$（也叫 $a[0]$）直接计算得到 $a_4$的地址，从而直接访问。

> #### * 随机存取结构
>
> 随机存取结构（Random Access Structure）通常指的是一种数据结构，其特点是能够在常数时间（$O(1)$ 时间复杂度）内访问任何一个元素。最典型的随机存取结构是数组（Array）。在数组中，每个元素都可以通过其索引直接访问，而无需遍历其他元素，这使得访问任何元素的时间复杂度都是 $𝑂(1)$。
>
> 随机存取和顺序存取（Sequential Access）是两种数据访问方式的对比：
>
> - **随机存取**：可以直接跳到数据结构中的任何位置并访问或修改数据。
> - **顺序存取**：数据必须按一定的顺序（例如从头到尾）访问，典型的例子是链表（Linked List）

### 顺序表的结构体

> [为什么要把这些放这里？](../01_DS/0111.md?id=关于实验)

```c
#define LIST_INIT_SIZE 100  // 顺序表存储空间的初始分配量
#define LISTINCREMENT  10   // 顺序表存储空间的分配增量

/* 顺序表元素类型定义 */
typedef int ElemType;

/*
 * 顺序表结构
 *
 * 注：elem在使用前需要先为其分配内存，且元素从elem[0]处开始存储
 */
typedef struct {
    ElemType* elem;     // 顺序表存储空间的基址（指向顺序表所占内存的起始位置）
    int length;   // 当前顺序表长度（包含多少元素）
    int listsize; // 当前分配的存储容量（可以存储多少元素）
} SqList;
```

#### 顺序表初始化

```c
/* 状态码 */
#define TRUE        1   // 真/是
#define FALSE       0   // 假/否
#define OK          1   // 通过/成功
#define ERROR       0   // 错误/失败
typedef int Status;
#ifndef OVERFLOW
#define OVERFLOW    -2  //堆栈上溢
#endif
/*
 * 初始化
 * 初始化成功则返回OK，否则返回ERROR。
 */
Status InitList(SqList* L) {
    // 分配指定容量的内存，如果分配失败，则返回NULL
    (*L).elem = (ElemType*) malloc(LIST_INIT_SIZE * sizeof(ElemType));
    if((*L).elem == NULL) {
        // 存储内存失败
        exit(OVERFLOW);
    }
    
    (*L).length = 0;                    // 初始化顺序表长度为0
    (*L).listsize = LIST_INIT_SIZE;     // 顺序表初始内存分配量
    
    return OK;                          // 初始化成功
}
```

> 读者可能注意到，这里的代码与书上的略有不同，
>
> 1. 这里加了许多[预定义]()内容，其实书上是省略了这一部分内容，在书中**Page10**有相关内容
>
> 2. 除此之外，还有代码上的略微不同， 比如 `*L`和 `&L`的不同，读者可访问[结构体]()和[指针]()。

除此之外，还有**增、删、查、改**等，难度较低，不再赘述。

### 数组的优点与局限性

数组存储在连续的内存空间内，且元素类型相同。这种做法包含丰富的先验信息，系统可以利用这些信息来优化数据结构的操作效率。

- **空间效率高**：数组为数据分配了连续的内存块，无须额外的结构开销。
- **支持随机访问**：数组允许在  时间内访问任何元素。
- **缓存局部性**：当访问数组元素时，计算机不仅会加载它，还会缓存其周围的其他数据，从而借助高速缓存来提升后续操作的执行速度。

连续空间存储是一把双刃剑，其存在以下局限性。

- **插入与删除效率低**：当数组中元素较多时，插入与删除操作需要移动大量的元素。
- **长度不可变**：数组在初始化后长度就固定了，扩容数组需要将所有数据复制到新数组，开销很大。
- **空间浪费**：如果数组分配的大小超过实际所需，那么多余的空间就被浪费了。

王道数据结构知识点：

![](./02_assest/im_4.png)

# 3. 链表

### 1. 单链表

- ~~链式存储结构：用一组任意的存储单元存储**数据结构**（这里是线性表)里的各元素(这组存储单元**可以是地址连续的，也可以是不连续的**)，并且每个存储元素有一个数据域，一个（或多个）指针域，数据域用来存储元素内容，指针域用来反映元素的逻辑关系(前后位置关系)，这种存储方式成为链式存储（也叫非随机存取的存储结构）。~~

- 链表：按照链式存储结构存储的线性表。

- 单链表：各元素只有一个指针域的链表（只含有一个指针域）

示意图 ： 

![image.png](./02_assest/im_5.png)

>  图中：2.3.4.5都是结构体，称之为**结点**，与顺序表不同的是，链表中的每个结点不是只单纯的存一个数据。而是一个**结构体**，结构体成员包括一个所存的数据，和下一个结点的地址。另外，顺序表中的地址是连续的，而链表中结点的地址是随机分配的。

#### 逻辑图示(带头结点的单链表)

![2.jpg](./02_assest/im_6.jpg)

- **表头指针**：存放单链表中第一个结点的地址的指针。【指向$a_0$ (带头结点时)或指向$a_1$(不带头结点时)的指针，上图中的$L$】

- **头结点**：带头结点的单链表中$L$ 【上图中的a1之前的结点 $a_0$】

- **尾结点**：单链表中最后一个结点，表尾结点的指针域指针为空。【 $a_n$】

### 链表结构体

```c
typedef struct LNode {
    ElemType data;      // 数据结点
    struct LNode* next; // 指向下一个结点的指针
} LNode;

// 指向单链表结点的指针
typedef LNode* LinkList;
```

这里需要用到[结构体](../01_DS/011?id=结构体)的内容

---

#### 注意事项

- 链表的元素一般称为“结点”。

- 头结点在链表中并不是必须的，仅仅是为了操作上的方便。

- 结点 $a_i$ 指其数据域为 $a_i$ 的结点，而 $p$ 则是指向$ai$的指针，俗称"p结点"。

- **链表有带头结点的链表和不带头结点的链表之分，带头结点的链表第一个元素为头结点$a_0$，$L$指向$a_0$; 不带头结点的链表第一个元素为头结点$a_1$，$L$指向$a_1$。**

- 单链表的操作

![3.jpg](./02_assest/im_7.jpg)

### 双向链表

双（向）链表就是每个结点中含有两个指针域的链表，其中一个指针域存放其前趋结点的地址，另一个指针域存放其后继结点的地址。

#### 逻辑图示

![4.jpg](./02_assest/im_8.jpg)

- **头结点**：双链表中第一个结点(上图中的$a_1$之前的结点$a_0$)

- **表头指针**：存放双链表中第一个结点的地址的指针。(指向$a_0$的指针)

- **开始结点**：存放双链表的第一个元素的结点。($a_1$)

- **表尾结点**：双链表中最后一个结点，表尾结点的指针域指针为空。($a_n$)

  ---

#### 数学表示

- 同线性表

- 寻址 一般用p,q等字母表示操作性指针，可用前驱指针域prior和后继指针域next访问表中任意节点，例如：
  p = &a[i]（即a[i] = p->data）
  那么
  a[i]的上一个元素地址是 p -> prior , 上一个元素值是 p->prior->data
  a[i]的下一个元素地址是 p -> next , 下一个元素值是 p->next->data
  一般的，有
  p->next-prior = p = p->prior->next

---

#### 注意事项