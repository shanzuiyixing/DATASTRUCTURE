# 前言



### 本项目是 对 数字媒体技术 董石 老师的 数据结构课程的复习笔记



1. 本课程基本上按着 数据结构 c语言 严蔚敏版 进行课程讲解
2. @2022/12/01 根据期末复习撰写
3. @2023/09/19 根据2022届改写
4. @2024/04/10 添加了 关于[数据结构课程](https://www.bilibili.com/video/BV1Kb41127fT?p=1)(讲师——陈越、何钦铭 转自：中国大学MOOC——浙江大学频道  **BV1Kb41127fT**)的笔记和理解，添加了根据 王道 2025 数据结构复习的内容



## 参考资料

> 因为网页不允许添加文件，所以以下文件类型连接（如.pdf等）改为本项目的  GIthub 仓库连接（需要科学上网），如有需要可以去往 Github 下载。

1. **电子书**

   [数据结构(C语言版)\].严蔚敏_吴伟民.扫描版.pdf]()

2. **笔记参考**

   [数据结构C语言严蔚敏版(第二版)超详细笔记附带课后习题*数据结构c语言版严蔚敏*别掉头发了小李的博客-CSDN博客](https://blog.csdn.net/chongyang_/article/details/109544719)

3. 课堂**ppt**

   [数据结构.zip]()

4. **代码高亮网站（卡顿严重）：**

   [代码在线高亮工具 | 将高亮美化的代码一键粘贴到 Word 或 OneNote 中](https://highlightcode.com/)

5. **老师力荐（数据结构可视化网站）：**

   [Data Structure Visualization](https://www.cs.usfca.edu/~galles/visualization/Algorithms.html)

6. **cs50**

   [【哈佛】计算机科学CS50-哈佛大学*哔哩哔哩*bilibili](https://www.bilibili.com/video/BV1Rb411378V/?spm_id_from=333.337.search-card.all.click&vd_source=3310f07bcb7152dc48cc5e65834e98b5)

7. 前置知识 ： 菜鸟教程 —— 指针

   [C 指针 | 菜鸟教程](https://www.runoob.com/cprogramming/c-pointers.html)

8. `git@github.com:xiufengcheng/DATASTRUCTURE.git`

   [GitHub - xiufengcheng/DATASTRUCTURE: 数据结构](https://github.com/xiufengcheng/DATASTRUCTURE)

   ![image.png](./assets_00/image%200.png)


9. 《数据结构》课本源码与习题解析 

   `git@github.com:kangjianwei/Data-Structure.git`

   [github.com](https://github.com/kangjianwei/Data-Structure/tree/master)

10. 从来没用过

    [云课堂ppt.zip]()
    
    

## 课程简介

### 什么是数据结构？

数据结构是**计算机存储、组织数据的方式**。它指的是相互之间存在一种或多种特定关系的数据元素的集合。通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率。数据结构往往与高效的检索算法和索引技术有关。

> 举个例子，**数据结构**就像数学的**数学公式**一样：数据结构帮助我们以逻辑和直观的方式思考问题，并找到解决问题的方法。它们是解决编程问题的工具，就像数学中的公式一样。

### 为什么学习数据结构？

学习数据结构之所以重要，是因为它是计算机科学的基础。数据结构提供了一种组织和存储数据的方式，使得我们可以高效地访问和修改数据。

1. **效率**：正确的数据结构可以显著提高算法的效率。
2. **问题解决**：数据结构帮助我们以逻辑和直观的方式思考问题，并找到解决问题的方法。
3. **内存管理**：了解不同数据结构如何在内存中表示，可以帮助我们更好地管理和优化内存的使用。
4. **可扩展性**：当系统需要处理更大量的数据时，良好的数据结构设计可以使系统更容易扩展。
5. **算法基础**：许多高级算法都建立在数据结构之上，例如图算法、搜索算法和动态规划。
6. **软件工程**：在软件开发过程中，数据结构是设计高效、可维护和可扩展软件的关键。
7. **理解计算机操作**：数据结构提供了理解计算机操作和资源管理（如缓存、内存、磁盘）的基础。
8. ......

### 本课程我们需要学习什么？

1. 常见的数据结构类型， 比如 堆栈、队列等
2. 对数据结构的简单操作
3. 一些经典但简单的算法





![image.png](./assets_00/image%202.png)



## 抽象数据类型（ADT）

抽象数据类型(Abstract Data Type 简称ADT)

是指一个数学模型以及定义在此数学模型上的一组操作。抽象数据类型需要通过固有数据类型（高级编程语言中已实现的数据类型）来实现。对一个抽象数据类型进行定义时，必须给出它的名字及各运算的运算符名，即函数名，并且规定这些函数的参数性质。一旦定义了一个抽象数据类型及具体实现，程序设计中就可以像使用基本数据类型那样，十分方便地使用抽象数据类型。

## 如何理解ADT

1. 抽象数据类型 = 逻辑结构+数据运算。逻辑结构不涉及数据在计算机中具体的实现和存储，这些操作是由存储结构决定的，这就是说，抽象数据类型只需考虑问题本身即可。

2. 类型是指一类数据。基本数据类型被人做是最基本地，不可再划分的数据，一般就是整形、浮点型、以及字符型。抽象数据类型是由若干基本数据类型归并之后形成的一种新的数据类型，这种类型由用户定义，功能操作比基本数据类型更多，一般包括结构体和类。

3. 抽象数据类型是在在不涉及具体的，和计算机系统相关的细节情况下，优先理解问题本身，在此基础上，实现用计算机求解问题的过程。这就是使用抽象数据类型的目的。

## 举例

![image.png](./assets_00/image%203.png)

也就是说，ADT定义了矩阵这一数据对象，也定义了对矩阵这一数据对象的各种操作，但是

**只是抽象的定义，不会具体确定矩阵元素是什么数据类型、用什么语言实现、代码具体编写**

参考 ：

[数据结构：基本概念【详解】_https://blog.csdn.net/real_fool_/article/details/1-CSDN博客](https://blog.csdn.net/Real_Fool_/article/details/112226369)


## 1. 线性表(linear list，简称list)

    ### 定义
    
    - 线性表是n(n≥0)个相同类型的数据元素构成的**有限序列**。
    
    #### 数学表示
    
    - $(a_1，a_2，…，a_n)$ 
    
    - 其中，n为线性表的长度，当 $n=0$时，表示线性表是一个空表，即表中不包含任何元素。
    
    - 对任意一对相邻元素$<a_i,a_{i+1}>(1≤i<n)$，$a_i$称为$a_{i+1}$的**前驱 ．**$a_{i+1}$称为　$a_i$的**后继**
    
    ---
    
    #### 图示
    
    ![0.jpg](前言+++线性表+5ce939ef-97bc-496d-a45d-0afdba0adf3b/0.jpg)
    
    #### 注意事项
    
    - 线性表除第一个和最后一个元素之外，每一格数据元素只有一个前驱和一个后继
    
    - 元素含义无所谓，可以指任何东西，但**元素类型必须相同**
    
    ## 2. 顺序表
    
    #### 定义
    
    - 顺序存储结构：用一组地址连续的存储单元依次存储**数据结构**(在这里是线性表)里各个元素，这种存储结构称为线性表的顺序存储结构。
    
    - 顺序表：按照顺序存储结构存储的线性表。
    
    #### 逻辑图示
    
    ![1.jpg](前言+++线性表+5ce939ef-97bc-496d-a45d-0afdba0adf3b/1.jpg)
    
    ---
    
    #### 数学表示
    
    - 同线性表
    
    - 求址
    
        - 每个元素占用k个存储单元，则
    
        $LOC$ : 求址函数
    
        $LOC(a_i)= LOC(a_1)+(i-1)*k (1≤i ≤n)$
    
        $LOC(a_{i+1})= LOC(a_i)+k (1≤i ≤n)$
    
    #### 注意事项
    
    - 访问顺序表中任意元素的时间都相等，具有这一特点的存储结构称为**随机存取结构**。
    
    **也就是说，在顺序表中，我们访问第 $i$个元素时，不需要遍历前 $i - 1$个元素，而是可以直接访问第 $i$个元素，**
    
    比如在数组$<1，2，3，4，5，7，8，9>$中，若我们要访问 $a_4$（也就是 $5$这个元素）我们可以根据据数组首地址 $a_0$（也叫 $a[0]$）直接计算得到 $a_4$的地址，从而直接访问。

#### 随机存取结构

1. 随机存取结构是一种数据存储的方式，它允许我们在恒定的时间内访问存储器中的任意位置的数据。这种结构的特点是，数据的物理位置与访问时间无关，即可以直接访问任何数据，而不需要按顺序访问前面的数据。这与顺序存取结构形成对比，后者需要按照一定的顺序来访问数据。

2. 在随机存取结构中，数据通常存储在连续的内存地址中。例如，如果我们有一个数组，数组的每个元素都分配有一个索引，我们可以通过这个索引直接计算出元素的存储地址，从而快速访问该元素。这种存储结构使得读取和写入操作的时间复杂度为 $O(1)$，也就是说，无论数组的大小如何，访问任何一个元素所需的时间都是恒定的

3. 随机存取结构的一个典型例子就是计算机中的随机存取存储器（RAM）。RAM中的每个存储单元都可以通过一个唯一的地址来访问，这使得CPU可以快速地读取或写入数据。这种快速访问的能力对于计算机的性能至关重要，因为它允许程序快速地处理大量数据

4. 总结来说，随机存取结构提供了一种高效的数据访问方式，它在计算机科学和数据处理中非常重要，特别是在需要快速访问和修改数据的应用场景中。

### 顺序表操作

    ```C++
    [in SqList.h]
    # define LIST_INIT_SIZE 100    //(默认)最大存储容量
    typedef struct {
        ElemType  elem [LIST_INIT_SIZE];   //存储数据元素的一维数组 
        int length;                        //线性表的当前长度
    } SqList;
    ```
    
    - 初始化
    
        - 分配空间
    
        - 设置长度
    
        #### 顺序表初始化操作
    
        ```C++
        [in SqList.h]
        void InitList_Sq( SqList &L, int maxsize=LIST_INIT_SIZE, int incresize=LISTINCREMENT ) // 构造一个最大容量为maxsize的顺序表 L
        {      
             L.elem=(ElemType *)malloc(maxsize*sizeof(ElemType)); // 分配一个最大容量为maxsize的数组空间
             if(!L.elem)  exit(1);           // 存储分配失败
              L.length=0;                    // 顺序表中当前所含元素个数为 0
              L.listsize=maxsize;            // 该顺序表可以容纳maxsize个数据元素
              L.incrementsize=incresize;     // 需要时可扩容incresize个元素空间
        }// InitList_Sq
        ```
    
    - 取值
    
    - 查找
    
    - 插入
    
        - 位置是否合法
    
        - 是否满
    
        - 表长+1
    
    - 删除

![image.png](前言+++线性表+5ce939ef-97bc-496d-a45d-0afdba0adf3b/image 4.png)

## 3. 链表

    链表
    
        单链表
    
        循环链表
    
        双向链表
    
    ### 单链表
    
    - ~~链式存储结构：用一组任意的存储单元存储**数据结构**（这里是线性表)里的各元素(这组存储单元**可以是地址连续的，也可以是不连续的**)，并且每个存储元素有一个数据域，一个（或多个）指针域，数据域用来存储元素内容，指针域用来反映元素的逻辑关系(前后位置关系)，这种存储方式成为链式存储（也叫非随机存取的存储结构）。~~
    
    - 链表：按照链式存储结构存储的线性表。
    
    - 单链表：各元素只有一个指针域的链表（只含有一个指针域）
    
    示意图 ： 
    
    ![image.png](前言+++线性表+5ce939ef-97bc-496d-a45d-0afdba0adf3b/image 5.png)
    
    图中：2.3.4.5都是结构体，称之为**结点**，与顺序表不同的是，链表中的每个结点不是只单纯的存一个数据。而是一个结构体，结构体成员包括一个所存的数据，和下一个结点的地址。另外，顺序表中的地址是连续的，而链表中结点的地址是随机分配的。
    
    #### 逻辑图示(带头结点的单链表)
    
    ![2.jpg](前言+++线性表+5ce939ef-97bc-496d-a45d-0afdba0adf3b/2.jpg)
    
    - **表头指针**：存放单链表中第一个结点的地址的指针。【指向$a_0$ (带头结点时)或指向$a_1$(不带头结点时)的指针，上图中的$L$】
    
    - **头结点**：带头结点的单链表中L【上图中的a1之前的结点$a_0$】
    
    - **开始结点**：，又称首节点，存放单链表的第一个存放元素的结点。【$a_1$】
    
    - **表尾结点**：单链表中最后一个结点，表尾结点的指针域指针为空。【$a_n$】
    
    ---
    
    #### 代码表示
    
    - 同线性表
    
    - 链表的寻址 一般用$p,q$等字母表示操作性指针，例如
如果 p = &a[i]，即 a[i] = p->data（或(*p).data）
那么
$a[i]$的下一个元素的地址是： $p -> next  或（ (*p).next） $
$a[i]$的下一个元素的值是： $p->next->data$

    ---
    
    #### 注意事项
    
    - 链表的元素一般称为“结点”。
    
    - 头结点在链表中并不是必须的，仅仅是为了操作上的方便。
    
    - 结点 $a_i$ 指其数据域为 $a_i$ 的结点，而 $p$ 则是指向$ai$的指针，俗称"p结点"。
    
    - **链表有带头结点的链表和不带头结点的链表之分，带头结点的链表第一个元素为头结点$a_0$，$L$指向$a_0$; 不带头结点的链表第一个元素为头结点$a_1$，$L$指向$a_1$。**
    
    - 单链表的操作
    
    ![3.jpg](前言+++线性表+5ce939ef-97bc-496d-a45d-0afdba0adf3b/3.jpg)
    
    ### 双向链表
    
    - 双（向）链表就是每个结点中含有两个指针域的链表，其中一个指针域存放其前趋结点的地址，另一个指针域存放其后继结点的地址。
    
    #### 逻辑图示
    
    ![4.jpg](前言+++线性表+5ce939ef-97bc-496d-a45d-0afdba0adf3b/4.jpg)
    
    - **头结点**：双链表中第一个结点(上图中的$a_1$之前的结点$a_0$)
    
    - **表头指针**：存放双链表中第一个结点的地址的指针。(指向$a_0$的指针)
    
    - **开始结点**：存放双链表的第一个元素的结点。($a_1$)
    
    - **表尾结点**：双链表中最后一个结点，表尾结点的指针域指针为空。($a_n$)
    
    ---
    
    #### 数学表示
    
    - 同线性表
    
    - 寻址 一般用p,q等字母表示操作性指针，可用前驱指针域prior和后继指针域next访问表中任意节点，例如：
p = &a[i]（即a[i] = p->data）
那么
a[i]的上一个元素地址是 p -> prior , 上一个元素值是 p->prior->data
a[i]的下一个元素地址是 p -> next , 下一个元素值是 p->next->data
一般的，有
p->next-prior = p = p->prior->next

    ---
    
    #### 注意事项
    
    - 节点p的存储地址既存放在其前驱结点的后继指针域中，也存在其后继节点的前驱指针域中。因此可随意在其上向前或向后移动，使得操作更加容易。
    
    - 操作上比单链表更加便利，但存储开销增大。
    
    - 双(向)链表是非循环的，有首尾节点，注意与双向循环链表区别开来


​    

    ```C
    //－－－－－ 单链表的存储结构－－－－－
        typedef struct LNode {
            ElemType data;          //结点的数据域
            struct LNode *next;     //结点的指针域
        } LNode, *LinkList;         //LinkList 为指向结构体 LNode 的指针类型
    ```
    
    ### 链表操作
    
        - 初始化（头节点）
    
        - 取值 （挨个访问）
    
        - 查找 （挨个查找）
    
        - 插入 
    
            - 插入前驱指针指向自己
    
            - 自己指向后继
    
        - 删除 （同理）
    
    ## 4. 表创建方法
    
        - 前插法
    
            - 新节点在首位 （空节点指向表头）
    
            ![image.png](前言+++线性表+5ce939ef-97bc-496d-a45d-0afdba0adf3b/image 6.png)
    
        - 后插法
    
            - 新节点在表尾 （空节点指向表尾）
    
            ![image.png](前言+++线性表+5ce939ef-97bc-496d-a45d-0afdba0adf3b/image 7.png)
