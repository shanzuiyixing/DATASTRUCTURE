# 排序

> 本章并不要求大家了解算法的代码（期末），只需可以**手动模拟**出各个算法的步骤即可，张贴代码用于学习

排序算法（sorting algorithm）用于对一组数据按照特定顺序进行排列。

## 定义

1. **主关键字（Primary Key）**

   定义：主关键字是表中的一个或多个字段，它的值能**唯一地标识表中的每一条记录**。简单来说，就像是每个人都有一个独一无二的身份证号码，在数据库的表中，主关键字就是这个 “身份证号码”，通过它可以准确地找到某一条特定的记录

2. **次关键字（Secondary Key）**

   定义：次关键字也叫辅助关键字，它是能够帮助识别记录，但不能唯一地标识记录的一个或多个字段。它是对主关键字的补充

3. **稳定性** ： 在排序过程中，如果存在两个或多个**具有相同关键字**的记录，排序前后这些相同关键字记录的相对顺序保持不变
4. **内部排序** ： 在排序过程中，待排序的所有数据元素全部存放在计算机内存中的排序算法

> 外部排序 ： 因为待排序的记录（元素）数量很大，以致内存不能一次容纳全部记录，在排序过程中需要读取外存

内部排序方法可大致分为插入排序、交换排序、选择排序、归并排序和计数排序五类

如果按照内部排序过程中所需的工作量来区分，则可分为三类：

- 简单的排序方法，时间复杂度为 $O (n^2)$
- 先进的排序方法，时间复杂度为 $O (nlogn)$
- 基数排序，时间复杂度为 $O (d・n)$

## 评价维度

- **运行效率（时间复杂度）**：我们期望排序算法的时间复杂度尽量低，且总体操作数量较少（时间复杂度中的常数项变小）。对于大数据量的情况，运行效率显得尤为重要。
- **就地性（空间复杂度）**：顾名思义，原地排序通过在原数组上直接操作实现排序，无须借助额外的辅助数组，从而节省内存。通常情况下，原地排序的数据搬运操作较少，运行速度也更快。
- **稳定性**：稳定排序在完成排序后，**相等元素在数组中的相对顺序不发生改变**

![](./assets_07/image_1.png)

# 插入排序

## 1. 直接插入排序

![](./assets_07/01.gif)

在**未排序区间**选择一个待排序元素，将该元素与其左侧**已排序区间**的元素逐一比较大小，并将该元素插入到正确的位置。

### 流程

设待排序元素为 `base` ，我们需要将从目标索引到 `base` 之间的所有元素向右移动一位，然后将 `base` 赋值给目标索引

![](./assets_07/insertion_operation.png)

具体流程：

1. 初始状态下，数组的第 `1` 个元素已完成排序。
2. 选取数组的第 `2` 个元素作为 `base` ，将其插入到正确位置后，**数组的前 2 个元素已排序**。
3. 选取第 `3` 个元素作为 `base` ，将其插入到正确位置后，**数组的前 3 个元素已排序**。
4. 以此类推，在最后一轮中，选取最后一个元素作为 `base` ，将其插入到正确位置后，**所有元素均已排序**。

> 简单来说，也就是：直接插入排序和打扑克牌时，**从牌桌上逐一拿起扑克牌，在手上排序的过程相同**
>
> 举例：
>
> 输入： `{5 2 4 6 1 3}`。
>
> 首先拿起第一张牌, 手上有 `{5}`。
>
> 拿起第二张牌 2, 把 2 insert 到手上的牌 `{5}`, 得到 `{2 5}`。
>
> 拿起第三张牌 4, 把 4 insert 到手上的牌 `{2 5}`, 得到 `{2 4 5}`
>
> 以此类推

![](./assets_07/insertion_sort_overview.png)

```c
//从大到小排序
void insertion_sort(int arr[], int len){
        int i,j,key;
        for (i=1;i!=len;++i){
                key = arr[i];
                j=i-1;
                while((j>=0) && (arr[j]>key)) {
                        arr[j+1] = arr[j];
                        j--;
                }
                arr[j+1] = key;
        }
}
```

> Q : 为什么`i`从`1`开始
>
> A ：因为默认**只有第一个元素的序列**是有序的，也就是说，我们需要从第二个元素开始排序
>
> tips ： 排序是如何进行的？
>
> 1. 从未排序区间取第一个数`x`
> 2. 将该数和已排序区间逐个比较
> 3. （假设已排序区间是从小到大排序）若 `x > 已排序的key`，**该key后移**
> 4. 插入`x`
>
> 希望读者注意，排序算法虽然看起来简单，但是在计算机实现的时候要注意具体的数据结构。（不考）
>
> 如 ： 对同一序列的链表形式和数组形式进行排序，复杂度并不相同

#### 特性总结：（插入排序默认为数组形式）

> 因为对插入排序的许多优化都用到了数组随机存取的特性

1. 元素集合越接近有序，直接插入排序算法的时间效率越高

2. **时间复杂度**：$O(N^2)$

   在最好的情况下，时间复杂度为 $O(N)$ ，在最坏的情况下，时间复杂度为 $O(N^2)$ 

3. 空间复杂度：$O(1)$，它是一种稳定的排序算法

4. 稳定性：稳定（在插入操作过程中，我们会将元素插入到相等元素的右侧，不会改变它们的顺序）

### * 折半插入排序

折半插入排序（Binary Insertion Sort）是插入排序的一种改进版本。它的基本思想是在插入第个元素时，利用折半查找（二分查找）来寻找插入位置，而不是逐个比较。

### * 2 - 路插入排序

2 - 路插入排序是在折半插入排序的基础上改进而来的，目的是减少排序过程中移动记录的次数

## 2. 希尔排序

希尔排序是基于插入排序的以下两点性质而提出改进方法的：

- 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率
- 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位

希尔排序通过**将比较的全部元素分为几个区域**来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步

然后算法再取**越来越小的步长**进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快）

### 流程

**设置一个初始增量`gap`，将数组分成分成`gap`组，组组排序**

1. 先选定一个整数`gap`，把待排序文件中所有记录分成`gap`个组，所有距离为`gap`的记录分在同一组内，并对每一组内的元素进行排序
2. 将`gap`逐渐减小重复上述分组和排序的工作
3. 当到达`gap=1`时，所有元素在统一组内排好序

下图是一个希尔排序示例

![image.png](./assets_07/image_2.png)

#### 希尔排序的特性总结：

1. 希尔排序是对直接插入排序的优化
2. 希尔排序的时间复杂度不好计算，因为`gap`的取值方法很多，导致很难去计算，这里不深究。（约为 $n^{1.3}$）
3. 空间复杂度$O(1)$
4. 稳定性：不稳定（跳跃式移动）

```c
void shell_sort(int array[], int length) {
    int h = 1;
    while (h < length / 3) {
        h = 3 * h + 1;
    }
    while (h >= 1) {
        for (int i = h; i < length; i++) {
            for (int j = i; j >= h && array[j] < array[j - h]; j -= h) {
                std::swap(array[j], array[j - h]); // C++
            }
        }
        h = h / 3;
    }
}
```

> Tips ： 
>
> - `gap`的选择视不同数据而不同
>
> - 当`gap = 1`时，也就是对整个数组进行排序
> - 在排序过程中，希尔排序实际上使用**插入**进行排序

# 交换排序

## 3. 冒泡排序

冒泡排序（bubble sort）通过连续地比较与交换相邻元素实现排序。这个过程就像气泡从底部升到顶部一样，因此得名冒泡排序。

![](./assets_07/bubble_operation_step1.png)

### 流程

1. 首先，对 `n` 个元素执行“冒泡”，**将数组的最大元素交换至正确位置**

2. 接下来，对剩余 `n−1` 个元素执行“冒泡”，**将第二大元素交换至正确位置**
3. 以此类推，经过 `n−1` 轮“冒泡”后，**前 `n−1` 大的元素都被交换至正确位置**
4. 仅剩的一个元素必定是最小元素，无须排序，因此数组排序完成。`n-1` 趟是因为最后两个元素时只需要一趟就可以完成


![](./assets_07/965d4fbb2bbdfb27494b207f092cd8ea.gif)


#### 特性总结：

1. 时间复杂度：$O(N^2)$

3. 空间复杂度：$O(1)$

4. 稳定性：稳定（由于在“冒泡”中**遇到相等元素不交换**）

## 4. 快速排序（quick sort）

> 它真的很快

快速排序（quick sort）又称**分区交换排序**，是一种基于**分治策略**的排序算法，运行高效，应用广泛。

快速排序的核心操作是“枢轴划分”，其目标是：

1. **选择数组中的某个元素作为“基准数”，将所有小于基准数的元素移到其左侧，而大于基准数的元素移到其右侧**
2. 递归排序子序列

### 流程

1. 选取数组最左端元素作为基准数，初始化两个指针 `i` 和 `j` 分别指向数组的两端。
2. 设置一个循环，在每轮中使用 `i`（`j`）分别寻找第一个比基准数大（小）的元素，然后交换这两个元素。
3. 循环执行步骤 `2.` ，直到 `i` 和 `j` 相遇时停止，最后将基准数交换至两个子数组的分界线

![](./assets_07/quick_sort_overview.png)

[【王道计算机考研 数据结构】](https://www.bilibili.com/video/BV1b7411N798/?p=90&share_source=copy_web&vd_source=f6ff1f6b32d145cf17622a2f18e41586) 

[【快速排序（双指针法）动画演示】](https://www.bilibili.com/video/BV1rW4y1x7Kh/?share_source=copy_web&vd_source=f6ff1f6b32d145cf17622a2f18e41586) 

```c
// [low, high] 为分区的范围，返回值为分区后 pivot 在数组中的下表
int partition(int a[], int low, int high) {
    int pivot = a[low];     // 设置基准元素为 [low, high] 区间中的第一个元素
    int l = low, r = high;  // 设置双指针
    while (l < r) {
        while (l < r && a[r] >= pivot) r--; // 从右到左寻找小于 pivot 的元素
        while (l < r && a[l] <= pivot) l++; // 从左到右寻找大于 pivot 的元素
        if (l < r) swap(a[l], a[r]);        // 交换两个元素
    }
    swap(a[low], a[r]); // 将 pivot 置换到中间位置
    return r;
}

void quickSort(int a[], int low, int high) {
    // 递归的结束条件，不要遗漏
    if (low < high) {
        int pivotIdx = partition(a, low, high);
        // 递归地对两个
        quickSort(a, low, pivotIdx - 1);
        quickSort(a, pivotIdx + 1, high);
    }
}
```

### 算法特性

- **时间复杂度为 $O(nlog⁡_2n)$**
- **空间复杂度为 O(n)、原地排序**：在输入数组完全倒序的情况下，达到最差递归深度 n ，使用 $O(n)$ 栈帧空间。排序操作是在原数组上进行的，未借助额外数组。
- **稳定性**：略

> *** Tips :** 
>
> 快速排序的平均时间为 $knlogn$，其中`n`为待排序序列中记录的个数，`k`为某个常数。在同量级的排序方法中，快速排序的常数因子`k`最小，因此平均而言，快速排序是较好的内部排序方法
>
> 通常采用 “三者取中” 的法则来选取枢轴记录，即比较 `L.r [low].key、L.r [high].key、L.r [(low + high) / 2].key`，取三者中关键字取中值的记录为枢轴，然后将该记录和 `L.r [low]` 互换
>
> 快速排序需要一个栈空间来实现递归
>
> - 在理想情况下，如果每趟排序都将记录序列均匀地分割成长度相近的两个子序列，栈的最大深度为$(\lfloor\log_{2}n\rfloor + 1)$
> - 在最坏情况下，如果每趟排序之后，枢轴位置均偏向子序列的一端，则栈的最大深度为 $n$。 
>
> 

# 选择排序

## 5. 简单选择排序

### 流程

1. 在要排序的一组数中，选出最小（或者最大）的一个数与第`1`个位置的数交换；
2. 然后在剩下的数中再找最小（或者最大）的与第 `2`个位置的数交换
3. 以此类推，直到 第 `n-1`个元素（倒数第二个数）和第 `n` 个元素（最后一个数）比较为止。

#### 图解

[11.2  选择排序 - Hello 算法 (hello-algo.com)](https://www.hello-algo.com/chapter_sorting/selection_sort/#__tabbed_1_1)

排序排序算法对含有 `n` 个元素的序列实现排序的思路是：

每次从待排序序列中找出最大值或最小值，查找过程重复 `n-1` 次

对于每次找到的最大值或最小值，通过**交换元素位置**的方式将它们放置到适当的位置，最终使整个序列变成有序序列

举个例子，我们使用选择排序算法对 `{14, 33, 27, 10, 35, 19, 42, 44}` 完成升序排序，需要经历以下几个步骤：

1. 遍历整个待排序序列，从中找到最小值 10 并与第二小元素 14 交换位置：

2. 待排序序列变成 {33, 27, 14, 35, 19, 42, 44}，从中找到最小值 14 并与第三小 33 交换位置：

3. 待排序序列变成 {27, 33, 35, 19, 42, 44}，从中找到最小值 19 并与 27 交换位置：

4. 待排序序列变成 {33, 35, 27, 42, 44}，从中找到最小值 27 并与 33 交换位置：

5. 待排序序列变成 {35, 33, 42, 44}，从中找到最小值 33 并与 35 交换位置：

6. 待排序序列变成 {35, 42, 44}，从中找到最小值 35，它的位置无需变动：

7. 待排序序列变成 {42, 44}，从中找到最小值 42，它的位置无需变动：

对于包含 n 个元素的待排序序列，选择排序算法中只需要找出 n-1 个“最小值”，最后剩下的元素的值必然最大。由此，我们就得到了一个升序序列 $\{10, 14, 19, 27, 33, 35, 42, 44\}$

> 简单来说，就是打扑克算法（需注意在代码中是交换操作）

![](./assets_07/selection-sort-animate.svg)

> 原地操作几乎是选择排序的唯一优点，当空间复杂度要求较高时，可以考虑选择排序；实际适用的场合非常罕见。

```c
/* 选择排序 */
void selectionSort(int nums[], int n) {
    // 外循环：未排序区间为 [i, n-1]
    for (int i = 0; i < n - 1; i++) {
        // 内循环：找到未排序区间内的最小元素
        int k = i;
        for (int j = i + 1; j < n; j++) {
            if (nums[j] < nums[k])
                k = j; // 记录最小元素的索引
        }
        // 将该最小元素与未排序区间的首个元素交换
        int temp = nums[i];
        nums[i] = nums[k];
        nums[k] = temp;
    }
}
```

#### **选择排序的特性总结：**

1. 直接选择排序思考非常好理解，但是效率不是很好(不论数组是否有序都会执行原步骤)。实际中很少使用

2. **时间复杂度为 $O(n^2)$**：外循环共 `n−1` 轮，第一轮的未排序区间长度为 `n` ，最后一轮的未排序区间长度为 `2` ，即各轮外循环分别包含 `n、n−1、…、3、2` 轮内循环，求和为 $(n−1)(n+2)\over2 $ 

3. **空间复杂度为 O(1)、原地排序**：指针 `i` 和 `j `使用常数大小的额外空间。

4. 稳定性：不稳定,如图所示，元素 `nums[i]` 有可能被交换至与其相等的元素的右边，导致两者的相对顺序发生改变。


![](./assets_07/selection_sort_instability.png)

## 6. 堆排序（树形选择排序的优化）

> 重点来咯
>
> 在多用户环境中,操作系统调度程序必须决定在若干进程中运行哪个进程。
>
> 一般一个进程只能被允许运行一个固定的时间片：
>
> 一种算法是使用一个队列，开始时作业被放到队列的末尾，调度程序将反复提取队列中的第一个作业并运行它，直到运行完毕或者该作业的时间片用完，并在作业未被运行完毕时把它放到队列的未尾，这种策略一般并不太合适，因为一些很短的作业由于一味等待运行而要花费很长的时间去处理。
>
> 短的作业要尽可能快地结束,这一点很重要，因此在已经被运行的作业当中这些短作业应该拥有优先权。此外，有些作业虽不短小但也很重要（高优先级进程），也应该拥有优先权。
>
> 这种特殊的应用似乎需要一类特殊的队列，我们称之为优先队列（priority queue）【堆】
>
> 我们将要使用的这种工具叫做二叉堆（binary heap），它的使用对于优先队列的实现是如此的普遍，以至于当堆(heap)这个词不加修饰地使用时一般都是指该数据结构的这种实现。 
>
> 在本小节，我们把二叉堆只叫做堆。同二叉查找树一样，堆也有两个性质，即结构性和堆序性。正如 AVL 树一样，对堆的一次操作可能破坏这两个性质中的一个，因此，堆的操作必须要到堆的所有性质都被满足时才能终止

堆排序（heap sort）是一种基于**堆数据结构**实现的高效排序算法

（二叉）堆（heap）是一种满**足特定条件的完全二叉树**，主要可分为两种类型，如图所示。

- 小顶（根）堆（min heap）：任意节点的值 ≤ 其子节点的值。
- 大顶（根）堆（max heap）：任意节点的值 ≥ 其子节点的值。

![](./assets_07/min_heap_and_max_heap.png)

> 思考题 ：大根堆的次大值一定在根的下一层？

### 堆的数据结构

堆也是一种数据结构，其定义了如下操作：

| 方法名      | 描述                                             | 时间复杂度 |
| :---------- | :----------------------------------------------- | :--------- |
| `push()`    | 元素入堆                                         | $O(log⁡n)$  |
| `pop()`     | 堆顶元素出堆                                     | $O(log⁡n)$  |
| `peek()`    | 访问堆顶元素（对于大 / 小顶堆分别为最大 / 小值） | $O(1)$     |
| `size()`    | 获取堆的元素数量                                 | $O(1)$     |
| `isEmpty()` | 判断堆是否为空                                   | $O(1)$     |

还有堆化和初始化两个操作

### 堆的存储与表示

堆是一棵被完全填满的二叉树，有可能的例外是在底层，底层上的元素从左到右填人。这样的树称为完全二叉树

“二叉树”章节讲过，完全二叉树非常适合用数组来表示。由于堆正是一种完全二叉树，**因此我们将采用数组来存储堆**。

当使用数组表示二叉树时，元素代表节点值，索引代表节点在二叉树中的位置。**节点指针通过索引映射公式来实现**。

如图所示，给定索引 `i` ，其左子节点的索引为 `2i+1` ，右子节点的索引为 `2i+2` ，父节点的索引为 `(i−1)/2`（向下整除）。当索引越界时，表示空节点或节点不存在。

![](./assets_07/representation_of_heap.png)

### 堆化

堆化是从某个结点开始，调整以该结点为根的子树，使其满足堆性质（以最大堆为例说明其过程）：

- 比较 当前结点 与 左右子结点 的值。
- 如果 某个子结点 比 当前结点 大，交换 当前结点 与 较大的子结点。
- 交换后，继续对 被交换的子结点 递归地执行堆化，直到子树满足堆性质。

```c
// 调整 i 结点为根的子树，使其满足堆的性质
void heapify(int heap[], int size, int i) {
    int largest = i;       // 假设当前结点是最大的
    int left = 2 * i + 1;  // 左结点下标
    int right = 2 * i + 2; // 右结点下标
    if (left < size && heap[left] > heap[largest]) {
        largest = left;
    }
    if (right < size && heap[right] > heap[largest]) {
        largest = right;
    }
    // 如果最大值不是根结点
    if (largest != i) {
        swap(heap[i], heap[largest]);
        heapify(heap, size, largest);  // 递归堆化受影响的子树
    }
}
```

### 插入

在堆中插入新元素后，需维护堆性质。

- 将新元素添加到堆底（数组末尾）。
- 从新元素开始，向上与父结点比较，若大于父结点则交换（上浮）。
- 重复上浮直到满足堆性质或到达堆顶。

> 这里并没有用到堆化，显然上述算法更加简单

```c
// 向大小为 size 的堆中插入元素 value
void heapInsert(int heap[], int *size, int value) {
    heap[*size] = value;
    int current = *size;
    int parent = (current - 1) / 2;
    
    // 如果新插入的元素比父结点的元素大，需要将其向上移动
    while (current > 0 && heap[current] > heap[parent]) {
        swap(heap[current], heap[current]); // 交换当前结点和父结点
        current = parent;
        parent = (current - 1) / 2; // 重新计算当前结点和其父结点的位置
    }
  
    (*size)++;  // 增加堆的大小
}
```

> 已知序列 25,13,10,12,9 是大根堆，在序列尾部插入新元素 18，将其再调整为大根堆，调整过程中元素之间进行的比较次数是（）。（408 2011）
>
> 答案：插入 18 后，首先将 18 与 10 比较，交换位置，再将 18 与 25 比较，不交换位置。共比较了 2 次
>
> ![](./assets_07/408-2011.png)

### 初始化

构造初始堆有两种方式：

- 方法 1：向一个初始为空的堆中不断插入新的元素。
- 方法 2：将无序数组转化为最大堆，核心是从最后一个非叶子结点开始，从后向前逐一对每个子树执行堆化操作。

```c
// 建立最大堆
void buildHeap(int heap[], int size) {
    // 从最后一个非叶结点开始，向前堆化每个结点
    for (int i = (size / 2) - 1; i >= 0; i--) {
        heapify(heap, size, i);
    }
}
//这里使用了方法2
```

### 堆顶元素出堆

堆顶元素是二叉树的根节点，即列表首元素。如果我们直接从列表中删除首元素，那么二叉树中所有节点的索引都会发生变化，这将使得后续使用堆化进行修复变得困难。为了尽量减少元素索引的变动，我们采用以下操作步骤。

1. 交换堆顶元素与堆底元素（交换根节点与最右叶节点）。
2. 交换完成后，将堆底从列表中删除（注意，由于已经交换，因此实际上删除的是原来的堆顶元素）。
3. 从根节点开始，**从顶至底执行堆化**。

```c
// 删除堆根结点
void heapDelete(int heap[], int *size) {
    if (*size <= 0) {
        return;
    }
    heap[0] = heap[*size - 1]; // 将堆顶元素替换为最后一个元素
    (*size)--;   // 将堆大小减 1
    heapify(heap, *size, 0);   // 调整堆
}
```

> 已知小根堆为 8,15,10,21,34,16,12，删除关键字 8 之后需重建堆，在此过程中，关键字之间的比较次数是（）。（408 2015）
>
> 答案：删除 8 后，将 12 移动到堆顶，第一 次是 15 和 10 比较，第二次是 10 和 12 比较并交换，第三次还需比较 12 和 16, 故比较次数为 3 次。

### 堆排序

#### 基本思想

1.首先将待排序的数组构造成一个大根堆，此时，整个数组的最大值就是堆结构的顶端

2.将根节点与末尾数交换，取出根节点（最大的值）（相当于删去根节点）

3.将剩余的`n-1`个数再构造成大根堆，再将顶端数与`n-1`位置的数交换，如此反复执行，便能得到有序数组

[【数据结构——堆排序】](https://www.bilibili.com/video/BV1aj411M71h/?share_source=copy_web&vd_source=f6ff1f6b32d145cf17622a2f18e41586) 

```c
void heapSort(int heap[], int size) {
    // 构建最大堆 buildHeap
    for (int i = (size / 2) - 1; i >= 0; i--) {
        heapify(heap, size, i);
    }
    
    // 一个个从堆中取出元素
    for (int i = size - 1; i >= 0; i--) {
        swap(heap[0], heap[i]); // 将当前最大元素（堆顶）移到数组末尾
        heapify(heap, i, 0);    // 调整堆以维护最大堆性质
    }
}
```

![image-20250727171009513](./assets_07/duipaixu.png)

**堆排序的特性总结：**

1. 堆排序使用堆来选数，效率就高了很多。

2. 时间复杂度：$O(N*logN)$  ： 建堆操作使用 $O(n)$ 时间。从堆中提取最大元素的时间复杂度为 $O(log⁡n)$ ，共循环 `n−1` 轮。

3. 空间复杂度：$O(1)$ : 几个指针变量使用 $O(1)$ 空间。元素交换和堆化操作都是在原数组上进行的。

4. 稳定性：不稳定，在交换堆顶元素和堆底元素时，相等元素的相对位置可能发生变化。


> - 插入（上滤法）和删除最小元素（下滤法）的最坏时间复杂度均为 $O(log N)$。
>
> - 建堆操作可在线性时间 $O(N)$ 内完成（自底向上调整）。
>
>   自底向上调整利用树的层次结构，底层节点调整代价低，高层节点数量少，总代价通过级数求和证明为线性。


## 7. 归并

一种基于分治策略的排序算法：

1. **划分阶段**：通过递归不断地将数组从中点处分开，将长数组的排序问题转换为短数组的排序问题。
2. **合并阶段**：当子数组长度为 $1$ 时终止划分，开始合并，持续地将左右两个较短的有序数组合并为一个较长的有序数组，直至结束。

![](./assets_07/merge_sort_overview.png)

1. 计算数组中点 `mid` ，递归划分左子数组（区间 `[left, mid]` ）和右子数组（区间 `[mid + 1, right]` ）。
2. 递归执行步骤 `1.` ，直至子数组区间长度为 1 时终止

![](./assets_07/merge_sort_step10.png)

```c
/* 合并左子数组和右子数组 */
void merge(int *nums, int left, int mid, int right) {
    // 左子数组区间为 [left, mid], 右子数组区间为 [mid+1, right]
    // 创建一个临时数组 tmp ，用于存放合并后的结果
    int tmpSize = right - left + 1;
    int *tmp = (int *)malloc(tmpSize * sizeof(int));
    // 初始化左子数组和右子数组的起始索引
    int i = left, j = mid + 1, k = 0;
    // 当左右子数组都还有元素时，进行比较并将较小的元素复制到临时数组中
    while (i <= mid && j <= right) {
        if (nums[i] <= nums[j]) {
            tmp[k++] = nums[i++];
        } else {
            tmp[k++] = nums[j++];
        }
    }
    // 将左子数组和右子数组的剩余元素复制到临时数组中
    while (i <= mid) {
        tmp[k++] = nums[i++];
    }
    while (j <= right) {
        tmp[k++] = nums[j++];
    }
    // 将临时数组 tmp 中的元素复制回原数组 nums 的对应区间
    for (k = 0; k < tmpSize; ++k) {
        nums[left + k] = tmp[k];
    }
    // 释放内存
    free(tmp);
}

/* 归并排序 */
void mergeSort(int *nums, int left, int right) {
    // 终止条件
    if (left >= right)
        return; // 当子数组长度为 1 时终止递归
    // 划分阶段
    int mid = left + (right - left) / 2;    // 计算中点
    mergeSort(nums, left, mid);      // 递归左子数组
    mergeSort(nums, mid + 1, right); // 递归右子数组
    // 合并阶段
    merge(nums, left, mid, right);
}
```

> 归并排序基本操作
>
> 1. 假设有左右两个有序数组
> 2. 创建数组`Tmp`（大小 = 左右大小相加），通过两个指针`i、j`，比较左右中的元素，将较小的数放入新数组
> 3. 逐步遍历两个数组

#### 特性总结：

1. 归并的缺点在于需要$O(N)$的空间复杂度，归并排序的思考更多的是解决在磁盘中的外排序问题。

2. 时间复杂度：$O(N*logN)$​

   划分产生高度为 $log⁡_𝑛$ 的递归树，每层合并的总操作数量为 $𝑛$ 

3. 空间复杂度：$O(N)$

4. 稳定性：稳定（在合并过程中，相等元素的次序不交换）

# 总结

| 排序方式 | 时间复杂度                     | 空间复杂度 | 是否稳定 |
| -------- | ------------------------------ | ---------- | -------- |
| 冒泡排序 | $O(n^2)$                       | $O(1)$     | 稳定     |
| 选择排序 | $O(n^2)$                       | $O(1)$     | 不稳定   |
| 插入排序 | $O(n^2)$                       | $O(1)$     | 稳定     |
| 希尔排序 | 取决于增量序列，最坏 $O(n^2)$  | $O(1)$     | 不稳定   |
| 归并排序 | $O(nlog⁡n)$                     | $O(n)$     | 稳定     |
| 快速排序 | 平均 $O(nlog⁡n)$，最坏 $O(n^2)$ | $O(log⁡n)$  | 不稳定   |
| 堆排序   | $O(nlog⁡n)$                     | $O(n)$     | 不稳定   |

| 排序算法 | 元素移动次数                  | 特点描述                                     |
| -------- | ----------------------------- | -------------------------------------------- |
| 冒泡排序 | 最坏 $O(n^2)$                 | 每次交换相邻元素，需多次移动，效率低。       |
| 选择排序 | 最多 $O(n)$                   | 每轮找到最小值，仅交换一次，移动少但比较多。 |
| 插入排序 | 平均 $O(n^2)$                 | 插入元素时可能需移动前面的一串元素。         |
| 归并排序 | $O(nlogn)$                    | 需借助辅助数组，频繁复制数据。               |
| 快速排序 | 平均 $O(nlogn)$ 最坏 $O(n^2)$ | 每次分区需交换元素，性能不稳定。             |
| 堆排序   | $O(nlogn)$                    | 堆化过程需交换，但整体移动比快排少。         |
| 希尔排序 | $O(n1.3∼2)$                   | 分段插入，元素跳跃移动，次数难精确界定。     |
| 基数排序 | $O(n⋅d)$ （*d* 为位数）       | 按位排序，通常用计数排序复制元素。           |



依次用

1. 直接插入排序
2. 希尔排序
3. 冒泡排序
4. 快速排序
5. 归并排序
6. 堆排序

对关键字序列`{7,三,5,8,3,6,1,2}`进行**升序**排序，画出每轮排序后的序列。

- 希尔排序初始步长为`4`，后续步长取半直到`1`；

- 快速排序以第1个元素为基准，先左分区后右分区；

- 归并排序采用2路归并；
- 堆排序采用大根堆，只需画出初始堆和输出一个关键字并调整后的堆即可（2个图）

 注：`三`和`3`大小相同，但画图时应区分，注意稳定的算法要保持其稳定性。（7个图可在一起上传，但请间隔清晰，标注清楚）

> 以下内容略

## * 基数排序

**基数排序**（英语：Radix sort）是一种非比较型[整数](https://zh.wikipedia.org/wiki/整数)[排序算法](https://zh.wikipedia.org/wiki/排序算法)，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。

![](./assets_07/radix_sort_overview.png)

为什么从最低位开始排序？

在连续的排序轮次中，后一轮排序会覆盖前一轮排序的结果。举例来说，如果第一轮排序结果 a<b ，而第二轮排序结果 a>b ，那么第二轮的结果将取代第一轮的结果。由于数字的高位优先级高于低位，因此应该先排序低位再排序高位。

### 算法特性

相较于计数排序，基数排序适用于数值范围较大的情况，**但前提是数据必须可以表示为固定位数的格式，且位数不能过大**。例如，浮点数不适合使用基数排序，因为其位数 k 过大，可能导致时间复杂度 $O(nk)≫O(n^2)$ 。

- **时间复杂度为 $O(nk)$**：设数据量为 `n`、数据为 `d` 进制、最大位数为 `k` ，则对某一位执行计数排序使用 `O(n+d)` 时间，排序所有 `k` 位使用 `O((n+d)k)` 时间。通常情况下，d 和 k 都相对较小，时间复杂度趋向 O(n) 。
- **空间复杂度为 $O(n+d)$、非原地排序**：与计数排序相同，基数排序需要**借助长度为 n 和 d 的数组 `res` 和 `counter`** 。
- **稳定排序**：当计数排序稳定时，基数排序也稳定；当计数排序不稳定时，基数排序无法保证得到正确的排序结果。

# * 外部排序

**外排序**（External sorting）是指能够处理极大量[数据](https://zh.wikipedia.org/wiki/数据)的[排序算法](https://zh.wikipedia.org/wiki/排序算法)。通常来说，外排序处理的数据不能一次装入[内存](https://zh.wikipedia.org/wiki/内存)，只能放在读写较慢的[外存储器](https://zh.wikipedia.org/wiki/外存储器)（通常是[硬盘](https://zh.wikipedia.org/wiki/硬盘)）上。外排序通常采用的是一种“排序-[归并](https://zh.wikipedia.org/w/index.php?title=归并&action=edit&redlink=1)”的策略。在排序阶段，先读入能放在内存中的数据量，将其排序输出到一个临时文件，依此进行，将待排序数据组织为多个有序的临时文件。而后在归并阶段将这些临时文件组合为一个大的有序文件，也即排序结果。

比如，要对900 [MB](https://zh.wikipedia.org/wiki/兆字节)的数据进行排序，但机器上只有100 MB的可用内存时，外归并排序按如下方法操作：

1. 读入100 MB的数据至内存中，用某种常规方式（如[快速排序](https://zh.wikipedia.org/wiki/快速排序)、[堆排序](https://zh.wikipedia.org/wiki/堆排序)、[归并排序](https://zh.wikipedia.org/wiki/归并排序)等方法）在内存中完成排序。
2. 将排序完成的数据写入磁盘。
3. 读入每个临时文件（顺串）的前10 MB（ = 100 MB / (9块 + 1)）的数据放入内存中的输入[缓冲区](https://zh.wikipedia.org/wiki/缓冲区)，最后的10 MB作为输出缓冲区。（实践中，将输入缓冲适当调小，而适当增大输出缓冲区能获得更好的效果。）
4. 执行九路[归并](https://zh.wikipedia.org/w/index.php?title=归并&action=edit&redlink=1)算法，将结果输出到输出缓冲区。一旦输出缓冲区满，将缓冲区中的数据写出至目标文件，清空缓冲区。一旦9个输入缓冲区中的一个变空，就从这个缓冲区关联的文件，读入下一个10M数据，除非这个文件已读完。这是“外归并排序”能在主存外完成排序的关键步骤 -- 因为“归并算法”(merge algorithm)对每一个大块只是顺序地做一轮访问(进行归并)，**每个大块不用完全载入主存**。

>  外部排序通常分为两个阶段：
>
> 1. **生成初始归并段**：将数据分块读入内存，使用内部排序算法（如快速排序）对每块数据排序后写回外存。
> 2. **多路归并**：将多个有序的归并段逐步合并为更大的有序段，直到最终合并为一个完整的有序文件。

## 置换选择排序

置换选择排序（Replacement Selection Sort）是外部排序的一个步骤，用于生成初始归并段， 其核心思想是在内存缓冲区有限的情况下，尽可能地生成较长的初始归并段。

### **基本原理**

1. **使用最小堆**：维护一个最小堆（优先队列）作为内存工作区，堆的大小为内存允许的最大记录数（M）。
2. 置换选择过程
   - 从输入文件读取 M 个记录，构建初始最小堆。
   - 重复以下步骤直到堆为空：
     - 判断是否有初始归并段
       - 如果不存在任何初始归并段的话，创建一个初始归并段，并添加工作区中的最小元素加入其中。
       - 否则将工作区中的元素与上一个初始归并段的最大值 MAXV 进行比较。
         - 如果工作区中的所有元素都 ≤ MAXV 的话，创建一个新的初始归并段，并添加工作区中的最小元素加入其中。
         - 否则找到第一个 > MAV 的元素，将其添加到上一个初始归并段的末尾。
     - 从输入文件中读取下一个值加入工作区。

举一个实际的例子，假设一个输入文件 FI 的内容为 51, 94, 37, 92, 14, 63, 15, 99, 48, 56, 23, 60, 31, 17, 43, 8, 90, 166, 100。

我们可以通过置换选择排序生成 3 个初始归并段，分别为 {37, 51, 63, 92, 94, 99} ，{14, 15, 23, 31, 48, 56, 60, 90, 166} ，{8, 17, 43, 100} 。

算法执行的过程如下表所示：

|               输出文件 FO                |   工作区 WA    |                         输入文件 FI                          |
| :--------------------------------------: | :------------: | :----------------------------------------------------------: |
|                    ——                    |       ——       | 51, 94, 37, 92, 14, 63, 15, 99, 48, 56, 23, 60, 31, 17, 43, 8, 90, 166, 100 |
|                    ——                    | 51, 94, 37, 92 | 14, 63, 15, 99, 48, 56, 23, 60, 31, 17, 43, 8, 90, 166, 100  |
|                    37                    | 51, 94, 14, 92 |   63, 15, 99, 48, 56, 23, 60, 31, 17, 43, 8, 90, 166, 100    |
|                  37, 51                  | 63, 94, 14, 92 |     15, 99, 48, 56, 23, 60, 31, 17, 43, 8, 90, 166, 100      |
|                37, 51, 63                | 15, 94, 14, 92 |       99, 48, 56, 23, 60, 31, 17, 43, 8, 90, 166, 100        |
|              37, 51, 63, 92              | 15, 94, 14, 99 |         48, 56, 23, 60, 31, 17, 43, 8, 90, 166, 100          |
|            37, 51, 63, 92, 94            | 15, 48, 14, 99 |           56, 23, 60, 31, 17, 43, 8, 90, 166, 100            |
|          37, 51, 63, 92, 94, 99          | 15, 48, 14, 56 |             23, 60, 31, 17, 43, 8, 90, 166, 100              |
|       **37, 51, 63, 92, 94, 99#**        | 15, 48, 14, 56 |             23, 60, 31, 17, 43, 8, 90, 166, 100              |
|                    14                    | 15, 48, 23, 56 |               60, 31, 17, 43, 8, 90, 166, 100                |
|                  14, 15                  | 60, 48, 23, 56 |                 31, 17, 43, 8, 90, 166, 100                  |
|                14, 15, 23                | 60, 48, 31, 56 |                   17, 43, 8, 90, 166, 100                    |
|              14, 15, 23, 31              | 60, 48, 17, 56 |                     43, 8, 90, 166, 100                      |
|            14, 15, 23, 31, 48            | 60, 43, 17, 56 |                       8, 90, 166, 100                        |
|          14, 15, 23, 31, 48, 56          | 60, 43, 17, 8  |                         90, 166, 100                         |
|        14, 15, 23, 31, 48, 56, 60        | 90, 43, 17, 8  |                           166, 100                           |
|      14, 15, 23, 31, 48, 56, 60, 90      | 166, 43, 17, 8 |                             100                              |
|   14, 15, 23, 31, 48, 56, 60, 90, 166    | 100, 43, 17, 8 |                              ——                              |
| **14, 15, 23, 31, 48, 56, 60, 90, 166#** | 100, 43, 17, 8 |                              ——                              |
|                    8                     |  100, 43, 17   |                              ——                              |
|                  8, 17                   |    100, 43     |                              ——                              |
|                8, 17, 43                 |      100       |                              ——                              |
|              8, 17, 43, 100              |       ——       |                              ——                              |
|           **8, 17, 43, 100#**            |     **——**     |                            **——**                            |

### **复杂度分析**

- **时间复杂度**：$O(nlogM)$，其中 n 为记录总数，M 为内存工作区大小。
- **空间复杂度**：O(*M*)，主要用于堆的存储

## 多路归并

多路归并的目标是将多个已经排序的初始归并段（子文件）合并成一个更大的有序文件。

其核心思想是从若干归并段中每次选取一个最小的元素加入工作区（小根堆），然后从工作区中选取最小的元素添加到输出文件中，通过这种方式可以保证每次添加到输出文件中的值是当前的最小值。

多路归并的具体过程如下：

1. 初始化：
   - 打开所有参与归并的初始归并段，并读取每个归并段的第一个元素。
   - 将这些元素放入一个数据结构中，以便快速找到最小值（例如，最小堆）。
2. 归并：
   - 从数据结构中取出最小的元素，将其输出到结果文件中。
   - 找到该元素所属的归并段，并从该归并段中读取下一个元素。
   - 将新读取的元素放入数据结构中，并调整数据结构，以保持有序。
   - 重复上述步骤，直到所有归并段都被处理完毕。
3. 结束：
   - 当所有归并段都为空时，归并过程结束，结果文件即为完全有序的文件。

## 最佳归并树

最佳归并树是在外部排序中的一个重要概念。在外部排序中，通常需要将多个顺串（已经内部排序好的子序列）进行归并。最佳归并树是一种能够使归并过程中的读写磁盘次数达到最少的归并方案所对应的树结构。

- 它是一棵 k - 叉树（k 为归并路数），其中叶节点代表初始的顺串，非叶节点代表归并后的新顺串，且每个非叶节点有 k 个子节点。

**构建原理**

考虑初始顺串个数不同的情况

- 当初始顺串的个数恰好是 k（归并路数）的整数倍时，构建 k - 叉树是比较简单的。例如，有 9 个顺串，归并路数 k = 3，那么可以构建一棵比较规整的 3 - 叉树。

- 但如果初始顺串个数不是 k 的整数倍，就需要**添加长度为 0 的 “虚段” 来构建平衡的 k - 叉树**。

  例如，有 8 个顺串，归并路数 k = 3。此时，为了构建最佳归并树，需要补充 1 个虚段，使总的节点数为 9（能构成一棵完整的 3 - 叉树）。

继续用上文中通过置换选择算法生成的三个初始归并段 {37, 51, 63, 92, 94, 99} ，{14, 15, 23, 31, 48, 56, 60, 90, 166} ，{8, 17, 43, 100} 作为例子。 对于这三个初始归并段，多路归并的过程如下（假设采用三路归并的话）：

| 归并段 1               | 归并段 2                            | 归并段 3       | 工作区       | 输出文件                                                     |
| ---------------------- | ----------------------------------- | -------------- | ------------ | ------------------------------------------------------------ |
| 37, 51, 63, 92, 94, 99 | 14, 15, 23, 31, 48, 56, 60, 90, 166 | 8, 17, 43, 100 | –            | –                                                            |
| 51, 63, 92, 94, 99     | 15, 23, 31, 48, 56, 60, 90, 166     | 17, 43, 100    | 8, 14, 37    | –                                                            |
| 51, 63, 92, 94, 99     | 15, 23, 31, 48, 56, 60, 90, 166     | 43, 100        | 14, 17, 37   | 8                                                            |
| 51, 63, 92, 94, 99     | 23, 31, 48, 56, 60, 90, 166         | 43, 100        | 15, 17, 37   | 8, 14                                                        |
| 51, 63, 92, 94, 99     | 31, 48, 56, 60, 90, 166             | 43, 100        | 17, 23, 37   | 8, 14, 15                                                    |
| 51, 63, 92, 94, 99     | 31, 48, 56, 60, 90, 166             | 100            | 23, 37, 43   | 8, 14, 15, 17                                                |
| 51, 63, 92, 94, 99     | 48, 56, 60, 90, 166                 | 100            | 31, 37, 43   | 8, 14, 15, 17, 23                                            |
| 51, 63, 92, 94, 99     | 56, 60, 90, 166                     | 100            | 37, 43, 48   | 8, 14, 15, 17, 23, 31                                        |
| 63, 92, 94, 99         | 56, 60, 90, 166                     | 100            | 43, 48, 51   | 8, 14, 15, 17, 23, 31, 37                                    |
| 63, 92, 94, 99         | 56, 60, 90, 166                     | –              | 48, 51, 100  | 8, 14, 15, 17, 23, 31, 37, 43                                |
| 63, 92, 94, 99         | 60, 90, 166                         | –              | 51, 56, 100  | 8, 14, 15, 17, 23, 31, 37, 43, 48                            |
| 92, 94, 99             | 60, 90, 166                         | –              | 56, 63, 100  | 8, 14, 15, 17, 23, 31, 37, 43, 48, 51                        |
| 92, 94, 99             | 90, 166                             | –              | 60, 63, 100  | 8, 14, 15, 17, 23, 31, 37, 43, 48, 51, 56                    |
| 92, 94, 99             | 166                                 | –              | 63, 90, 100  | 8, 14, 15, 17, 23, 31, 37, 43, 48, 51, 56, 60                |
| 94, 99                 | 166                                 | –              | 90, 92, 100  | 8, 14, 15, 17, 23, 31, 37, 43, 48, 51, 56, 60, 63            |
| 94, 99                 | –                                   | –              | 92, 100, 166 | 8, 14, 15, 17, 23, 31, 37, 43, 48, 51, 56, 60, 63, 90        |
| 99                     | –                                   | –              | 94, 100, 166 | 8, 14, 15, 17, 23, 31, 37, 43, 48, 51, 56, 60, 63, 90, 92    |
| –                      | –                                   | –              | 99, 100, 166 | 8, 14, 15, 17, 23, 31, 37, 43, 48, 51, 56, 60, 63, 90, 92, 94 |
| –                      | –                                   | –              | –            | 8, 14, 15, 17, 23, 31, 37, 43, 48, 51, 56, 60, 63, 90, 92, 94, 99, 100, 166 |

### 胜者树

在进行 k 路归并（如外排序）时，我们需要从多个有序子序列中 **快速找出当前最小元素**，然后将其输出并替换为该序列的下一个元素。

最简单的做法就是每次遍历序列头部元素，找到最小值。该方法的时间复杂度为 O(k)，效率比较低，尤其是当 k 比较大时。

树形结构优化（胜者树/败者树）优化的目的就是优化这个过程：

> 用一棵完全二叉树维护每一轮比较的结果，使得我们可以在 $O(logk)$ 时间内完成最小值查找与更新。

胜者树可以理解为 **胜者晋级的淘汰赛模型**：类比体育比赛的淘汰制，每一轮两个选手进行比较，胜者晋级上一轮，最终全局胜者抵达根节点。



在胜者树中，每个 **内部结点记录的是该轮比较的胜者**（较小的元素），而叶子节点表示每个输入归并段的当前值。因此，整棵树的**根节点就表示全局最小值**。

当某个归并段输出了最小值并更新为下一个元素时，需要 **从该叶子节点向上，逐层与兄弟节点重新比较，构建新的胜者路径**，最终将新的最小值更新到根节点
