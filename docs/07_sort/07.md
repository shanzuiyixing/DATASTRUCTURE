# 排序

排序算法（sorting algorithm）用于对一组数据按照特定顺序进行排列。

## 评价维度

- **运行效率**：我们期望排序算法的时间复杂度尽量低，且总体操作数量较少（时间复杂度中的常数项变小）。对于大数据量的情况，运行效率显得尤为重要。
- **就地性**：顾名思义，原地排序通过在原数组上直接操作实现排序，无须借助额外的辅助数组，从而节省内存。通常情况下，原地排序的数据搬运操作较少，运行速度也更快。
- **稳定性**：稳定排序在完成排序后，**相等元素在数组中的相对顺序不发生改变**

![](./assets_07/image_1.png)

## 1. 直接插入排序

![](./assets_07/01.gif)

在**未排序区间**选择一个基准元素，将该元素与其左侧**已排序区间**的元素逐一比较大小，并将该元素插入到正确的位置。

开启一个循环，每轮从未排序区间选择最小的元素，将其放到已排序区间的末尾

### 流程

设基准元素为 `base` ，我们需要将从目标索引到 `base` 之间的所有元素向右移动一位，然后将 `base` 赋值给目标索引

![](./assets_07/insertion_operation.png)

具体流程：

1. 初始状态下，数组的第 `1` 个元素已完成排序。
2. 选取数组的第 `2` 个元素作为 `base` ，将其插入到正确位置后，**数组的前 2 个元素已排序**。
3. 选取第 `3` 个元素作为 `base` ，将其插入到正确位置后，**数组的前 3 个元素已排序**。
4. 以此类推，在最后一轮中，选取最后一个元素作为 `base` ，将其插入到正确位置后，**所有元素均已排序**。

![](./assets_07/insertion_sort_overview.png)


#### 特性总结：

1. 元素集合越接近有序，直接插入排序算法的时间效率越高

2. **时间复杂度**：$O(N^2)$

   在最好的情况下，时间复杂度为 $O(N)$ ，在最坏的情况下，时间复杂度为 $O(N^2)$ 

3. 空间复杂度：$O(1)$，它是一种稳定的排序算法

4. 稳定性：稳定（在插入操作过程中，我们会将元素插入到相等元素的右侧，不会改变它们的顺序）


> 在考虑排序算法中，时间复杂度以**“最坏”**的情况考虑
>
> 例如：当需要从大到小排列一个数组，我们考虑该数组为从小到大排列，然后计算其时间复杂度。

### 折半插入排序



## 2. 希尔排序（Shellsort）

尔排序是基于插入排序的以下两点性质而提出改进方法的：

- 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率
- 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位

希尔排序通过**将比较的全部元素分为几个区域**来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步

然后算法再取**越来越小的步长**进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快）

### 流程

**设置一个初始增量`gap`，将数组分成分成`gap`组，组组排序**

1. 先选定一个整数`gap`，把待排序文件中所有记录分成`gap`个组，所有距离为`gap`的记录分在同一组内，并对每一组内的元素进行排序
2. 将`gap`逐渐减小重复上述分组和排序的工作
3. 当到达`gap=1`时，所有元素在统一组内排好序

下图是一个希尔排序示例

![image.png](./assets_07/image_2.png)

#### 希尔排序的特性总结：

1. 希尔排序是对直接插入排序的优化
2. 希尔排序的时间复杂度不好计算，因为`gap`的取值方法很多，导致很难去计算，这里不深究。
3. 空间复杂度$O(1)$
6. 稳定性：不稳定（跳跃式移动）

## 3. 冒泡排序

冒泡排序（bubble sort）通过连续地比较与交换相邻元素实现排序。这个过程就像气泡从底部升到顶部一样，因此得名冒泡排序。

![](./assets_07/bubble_operation_step1.png)

### 流程

1. 首先，对 `n` 个元素执行“冒泡”，**将数组的最大元素交换至正确位置**

2. 接下来，对剩余 `n−1` 个元素执行“冒泡”，**将第二大元素交换至正确位置**
3. 以此类推，经过 `n−1` 轮“冒泡”后，**前 `n−1` 大的元素都被交换至正确位置**
4. 仅剩的一个元素必定是最小元素，无须排序，因此数组排序完成。`n-1` 趟是因为最后两个元素时只需要一趟就可以完成


![](./assets_07/965d4fbb2bbdfb27494b207f092cd8ea.gif)


#### 特性总结：

1. 时间复杂度：$O(N^2)$

3. 空间复杂度：$O(1)$

4. 稳定性：稳定（由于在“冒泡”中**遇到相等元素不交换**）

## 4. 快速排序

快速排序（quick sort）是一种基于**分治策略**的排序算法，运行高效，应用广泛。

快速排序的核心操作是“哨兵划分”，其目标是：**选择数组中的某个元素作为“基准数”，将所有小于基准数的元素移到其左侧，而大于基准数的元素移到其右侧**

### 流程

1. 选取数组最左端元素作为基准数，初始化两个指针 `i` 和 `j` 分别指向数组的两端。
2. 设置一个循环，在每轮中使用 `i`（`j`）分别寻找第一个比基准数大（小）的元素，然后交换这两个元素。
3. 循环执行步骤 `2.` ，直到 `i` 和 `j` 相遇时停止，最后将基准数交换至两个子数组的分界线

![](./assets_07/quick_sort_overview.png)

[【王道计算机考研 数据结构】](https://www.bilibili.com/video/BV1b7411N798/?p=90&share_source=copy_web&vd_source=f6ff1f6b32d145cf17622a2f18e41586) 

[【快速排序（双指针法）动画演示】](https://www.bilibili.com/video/BV1rW4y1x7Kh/?share_source=copy_web&vd_source=f6ff1f6b32d145cf17622a2f18e41586) 

### 算法特性

- **时间复杂度为 $O(nlog⁡_2n)$、非自适应排序**
- **空间复杂度为 O(n)、原地排序**：在输入数组完全倒序的情况下，达到最差递归深度 n ，使用 $O(n)$ 栈帧空间。排序操作是在原数组上进行的，未借助额外数组。
- **非稳定排序**：在哨兵划分的最后一步，基准数可能会被交换至相等元素的右侧

## 5. 选择排序

### 流程

1. 在要排序的一组数中，选出最小（或者最大）的一个数与第1个位置的数交换；
2. 然后在剩下的数中再找最小（或者最大）的与第2个位置的数交换
3. 以此类推，直到 第n-1个元素（倒数第二个数）和第n个元素（最后一个数）比较为止。

#### 图解

[11.2  选择排序 - Hello 算法 (hello-algo.com)](https://www.hello-algo.com/chapter_sorting/selection_sort/#__tabbed_1_1)

排序排序算法对含有 n 个元素的序列实现排序的思路是：每次从待排序序列中找出最大值或最小值，查找过程重复 n-1 次。对于每次找到的最大值或最小值，通过交换元素位置的方式将它们放置到适当的位置，最终使整个序列变成有序序列。

举个例子，我们使用选择排序算法对 {14, 33, 27, 10, 35, 19, 42, 44} 完成升序排序，需要经历以下几个步骤：

1. 遍历整个待排序序列，从中找到最小值 10 并与第二小元素 14 交换位置：

2. 待排序序列变成 {33, 27, 14, 35, 19, 42, 44}，从中找到最小值 14 并与第三小 33 交换位置：

3. 待排序序列变成 {27, 33, 35, 19, 42, 44}，从中找到最小值 19 并与 27 交换位置：

4. 待排序序列变成 {33, 35, 27, 42, 44}，从中找到最小值 27 并与 33 交换位置：

5. 待排序序列变成 {35, 33, 42, 44}，从中找到最小值 33 并与 35 交换位置：

6. 待排序序列变成 {35, 42, 44}，从中找到最小值 35，它的位置无需变动：

7. 待排序序列变成 {42, 44}，从中找到最小值 42，它的位置无需变动：

![https://c.biancheng.net/uploads/allimg/210820/2-210R010433b54.gif](排序+425a8bba-9cb1-4512-bf45-10b14d20a9fa/2-210R010433b54.gif)

![https://c.biancheng.net/uploads/allimg/210820/2-210R010435E00.gif](排序+425a8bba-9cb1-4512-bf45-10b14d20a9fa/2-210R010435E00.gif)

![https://c.biancheng.net/uploads/allimg/210820/2-210R0104411461.gif](排序+425a8bba-9cb1-4512-bf45-10b14d20a9fa/2-210R0104411461.gif)

![https://c.biancheng.net/uploads/allimg/210820/2-210R010442MK.gif](排序+425a8bba-9cb1-4512-bf45-10b14d20a9fa/2-210R010442MK.gif)

![https://c.biancheng.net/uploads/allimg/210820/2-210R0104446328.gif](排序+425a8bba-9cb1-4512-bf45-10b14d20a9fa/2-210R0104446328.gif)

![https://c.biancheng.net/uploads/allimg/210820/2-210R0104505437.gif](排序+425a8bba-9cb1-4512-bf45-10b14d20a9fa/2-210R0104505437.gif)

![https://c.biancheng.net/uploads/allimg/210820/2-210R0104521M3.gif](排序+425a8bba-9cb1-4512-bf45-10b14d20a9fa/2-210R0104521M3.gif)

对于包含 n 个元素的待排序序列，选择排序算法中只需要找出 n-1 个“最小值”，最后剩下的元素的值必然最大。由此，我们就得到了一个升序序列 $\{10, 14, 19, 27, 33, 35, 42, 44\}$。

> 选择排序算法可以看作是冒泡排序算法的“改良版”。和后者相比，选择排序算法大大减少了交换数据存储位置的操作。

#### **选择排序的特性总结：**

1. 直接选择排序思考非常好理解，但是效率不是很好(不论数组是否有序都会执行原步骤)。实际中很少使用

2. 时间复杂度：$O(N^2)$

3. 空间复杂度：$O(1)$

4. 稳定性：不稳定

## 6. 堆排序

> 重点来咯

堆排序（heap sort）是一种基于**堆数据结构**实现的高效排序算法

堆（heap）是一种满**足特定条件的完全二叉树**，主要可分为两种类型，如图所示。

- 小顶（根）堆（min heap）：任意节点的值 ≤ 其子节点的值。
- 大顶（根）堆（max heap）：任意节点的值 ≥ 其子节点的值。

![](./assets_07/min_heap_and_max_heap.png)





而堆排序是根据堆的这种数据结构设计的一种排序，下面先来看看什么是大根堆和小根堆

性质：每个结点的值都大于其左孩子和右孩子结点的值，称之为大根堆；每个结点的值都小于其左孩子和右孩子结点的值，称之为小根堆。如下图

![image.png](排序+425a8bba-9cb1-4512-bf45-10b14d20a9fa/image 3.png)

#### 基本思想

1.首先将待排序的数组构造成一个大根堆，此时，整个数组的最大值就是堆结构的顶端

2.将根节点与末尾数交换，取出根节点（最大的值）（相当于删去根节点）

3.将剩余的n-1个数再构造成大根堆，再将顶端数与n-1位置的数交换，如此反复执行，便能得到有序数组

[https://www.bilibili.com/video/BV1aj411M71h/?spm_id_from=333.337.search-card.all.click&vd_source=3310f07bcb7152dc48cc5e65834e98b5](https://www.bilibili.com/video/BV1aj411M71h/?spm_id_from=333.337.search-card.all.click&vd_source=3310f07bcb7152dc48cc5e65834e98b5)

#### **堆排序的特性总结：**

1. 堆排序使用堆来选数，效率就高了很多。

2. 时间复杂度：$O(N*logN)$

3. 空间复杂度：$O(1)$

4. 稳定性：不稳定

## 7. 归并

一种基于分治策略的排序算法：

1. **划分阶段**：通过递归不断地将数组从中点处分开，将长数组的排序问题转换为短数组的排序问题。
2. **合并阶段**：当子数组长度为 $1$ 时终止划分，开始合并，持续地将左右两个较短的有序数组合并为一个较长的有序数组，直至结束。

![](./assets_07/merge_sort_overview.png)

#### 特性总结：

1. 归并的缺点在于需要$O(N)$的空间复杂度，归并排序的思考更多的是解决在磁盘中的外排序问题。

2. 时间复杂度：$O(N*logN)$​

   划分产生高度为 $log⁡_𝑛$ 的递归树，每层合并的总操作数量为 $𝑛$ 

3. 空间复杂度：$O(N)$

4. 稳定性：稳定（在合并过程中，相等元素的次序不交换）



