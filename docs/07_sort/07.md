![image.png](排序+425a8bba-9cb1-4512-bf45-10b14d20a9fa/image.png)

# 排序

排序算法（sorting algorithm）用于对一组数据按照特定顺序进行排列。

## 评价维度

- **运行效率**：我们期望排序算法的时间复杂度尽量低，且总体操作数量较少（时间复杂度中的常数项变小）。对于大数据量的情况，运行效率显得尤为重要。
- **就地性**：顾名思义，原地排序通过在原数组上直接操作实现排序，无须借助额外的辅助数组，从而节省内存。通常情况下，原地排序的数据搬运操作较少，运行速度也更快。
- **稳定性**：稳定排序在完成排序后，**相等元素在数组中的相对顺序不发生改变**

![image.png](排序+425a8bba-9cb1-4512-bf45-10b14d20a9fa/image 1.png)

## 1. 直接排序（插入排序）

[c.biancheng.net](https://c.biancheng.net/uploads/allimg/210820/2-210R0104HD32.gif)

在未排序区间选择一个基准元素，将该元素与其左侧已排序区间的元素逐一比较大小，并将该元素插入到正确的位置。

开启一个循环，每轮从未排序区间选择最小的元素，将其放到已排序区间的末尾

### 流程

1. 初始状态下，数组的第 1 个元素已完成排序。
2. 选取数组的第 2 个元素作为 `base` ，将其插入到正确位置后，**数组的前 2 个元素已排序**。
3. 选取第 3 个元素作为 `base` ，将其插入到正确位置后，**数组的前 3 个元素已排序**。
4. 以此类推，在最后一轮中，选取最后一个元素作为 `base` ，将其插入到正确位置后，**所有元素均已排序**。

![](./assets_07/insertion_sort_overview.png)


#### 特性总结：

1. 元素集合越接近有序，直接插入排序算法的时间效率越高

2. **时间复杂度**：$O(N^2)$

3. 空间复杂度：$O(1)$，它是一种稳定的排序算法

4. 稳定性：稳定（在插入操作过程中，我们会将元素插入到相等元素的右侧，不会改变它们的顺序）


> 在考虑排序算法中，时间复杂度以**“最坏”**的情况考虑，例如：当需要从大到小派列一个数组，我们考虑该数组为从小到大派列，然后计算其时间复杂度。

## 2. 希尔排序（）

**初始增量n，分成n组，组组排序**

- 将待排序序列划分成多个子序列，使用普通的插入排序算法对每个子序列进行排序；

- 按照不同的划分标准，重复执行第一步；

- 使用普通的插入排序算法对整个序列进行排序。

下图是一个希尔排序示例

![image.png](./assets_07/image_2.png)

> 希尔排序

    1. 先选定一个整数$gap$，把待排序文件中所有记录分成$gap$个组，所有距离为$gap$的记录分在同一组内，并对每一组内的元素进行排序。
    
    2. 当到达$gap=1$时，所有元素在统一组内排好序。
    
    3. 然后将$gap$逐渐减小重复上述分组和排序的工作。

### 希尔排序的特性总结：

1. 希尔排序是对直接插入排序的优化。

2. 当gap > 1时都是预排序，目的是让数组更接近于有序。当gap == 1时，数组已经接近有序的了，这样就会很快。这样整体而言，可以达到优化的效果。

3. 希尔排序的时间复杂度不好计算，因为gap的取值方法很多，导致很难去计算，这里不深究。

4. 时间复杂度$O(N^{1.5})$

5. 空间复杂度$O(1)$

6. 稳定性：不稳定（跳跃式移动）

## 3. 冒泡排序

冒泡排序（bubble sort）通过连续地比较与交换相邻元素实现排序。这个过程就像气泡从底部升到顶部一样，因此得名冒泡排序。

![](./assets_07/bubble_operation_step1.png)

### 流程

1. 两两元素相比，前一个比后一个大就交换，直到将最大的元素交换到末尾位置。这是第一趟

2. 一共进行$n-1$趟这样的交换将可以把所有的元素排好。

3. $n-1$​趟是因为最后两个元素时只需要一趟就可以完成


![](./assets_07/965d4fbb2bbdfb27494b207f092cd8ea.gif)


#### 特性总结：

1. 冒泡排序是一种非常容易理解的排序

2. 时间复杂度：$O(N^2)$

3. 空间复杂度：$O(1)$

4. 稳定性：稳定（由于在“冒泡”中**遇到相等元素不交换**）

## 4. 快速排序

- 从待排序序列中任选一个元素（假设为 $pivot$）作为中间元素，将所有比 $pivot$ 小的元素移动到它的左边，所有比 $pivot $大的元素移动到它的右边；

- $pivot $ 左右两边的子序列看作是两个待排序序列，各自重复执行第一步。直至所有的子序列都不可再分（仅包含 1 个元素或者不包含任何元素），整个序列就变成了一个有序序列。

[https://www.bilibili.com/video/BV1rW4y1x7Kh/?spm_id_from=333.337.search-card.all.click&vd_source=3310f07bcb7152dc48cc5e65834e98b5](https://www.bilibili.com/video/BV1rW4y1x7Kh/?spm_id_from=333.337.search-card.all.click&vd_source=3310f07bcb7152dc48cc5e65834e98b5)

## 5. 选择排序

### 流程

1. 在要排序的一组数中，选出最小（或者最大）的一个数与第1个位置的数交换；
2. 然后在剩下的数中再找最小（或者最大）的与第2个位置的数交换
3. 以此类推，直到 第n-1个元素（倒数第二个数）和第n个元素（最后一个数）比较为止。

#### 图解

[11.2  选择排序 - Hello 算法 (hello-algo.com)](https://www.hello-algo.com/chapter_sorting/selection_sort/#__tabbed_1_1)

排序排序算法对含有 n 个元素的序列实现排序的思路是：每次从待排序序列中找出最大值或最小值，查找过程重复 n-1 次。对于每次找到的最大值或最小值，通过交换元素位置的方式将它们放置到适当的位置，最终使整个序列变成有序序列。

举个例子，我们使用选择排序算法对 {14, 33, 27, 10, 35, 19, 42, 44} 完成升序排序，需要经历以下几个步骤：

1. 遍历整个待排序序列，从中找到最小值 10 并与第二小元素 14 交换位置：

2. 待排序序列变成 {33, 27, 14, 35, 19, 42, 44}，从中找到最小值 14 并与第三小 33 交换位置：

3. 待排序序列变成 {27, 33, 35, 19, 42, 44}，从中找到最小值 19 并与 27 交换位置：

4. 待排序序列变成 {33, 35, 27, 42, 44}，从中找到最小值 27 并与 33 交换位置：

5. 待排序序列变成 {35, 33, 42, 44}，从中找到最小值 33 并与 35 交换位置：

6. 待排序序列变成 {35, 42, 44}，从中找到最小值 35，它的位置无需变动：

7. 待排序序列变成 {42, 44}，从中找到最小值 42，它的位置无需变动：

![https://c.biancheng.net/uploads/allimg/210820/2-210R010433b54.gif](排序+425a8bba-9cb1-4512-bf45-10b14d20a9fa/2-210R010433b54.gif)

![https://c.biancheng.net/uploads/allimg/210820/2-210R010435E00.gif](排序+425a8bba-9cb1-4512-bf45-10b14d20a9fa/2-210R010435E00.gif)

![https://c.biancheng.net/uploads/allimg/210820/2-210R0104411461.gif](排序+425a8bba-9cb1-4512-bf45-10b14d20a9fa/2-210R0104411461.gif)

![https://c.biancheng.net/uploads/allimg/210820/2-210R010442MK.gif](排序+425a8bba-9cb1-4512-bf45-10b14d20a9fa/2-210R010442MK.gif)

![https://c.biancheng.net/uploads/allimg/210820/2-210R0104446328.gif](排序+425a8bba-9cb1-4512-bf45-10b14d20a9fa/2-210R0104446328.gif)

![https://c.biancheng.net/uploads/allimg/210820/2-210R0104505437.gif](排序+425a8bba-9cb1-4512-bf45-10b14d20a9fa/2-210R0104505437.gif)

![https://c.biancheng.net/uploads/allimg/210820/2-210R0104521M3.gif](排序+425a8bba-9cb1-4512-bf45-10b14d20a9fa/2-210R0104521M3.gif)

对于包含 n 个元素的待排序序列，选择排序算法中只需要找出 n-1 个“最小值”，最后剩下的元素的值必然最大。由此，我们就得到了一个升序序列 $\{10, 14, 19, 27, 33, 35, 42, 44\}$。

> 选择排序算法可以看作是冒泡排序算法的“改良版”。和后者相比，选择排序算法大大减少了交换数据存储位置的操作。

#### **选择排序的特性总结：**

1. 直接选择排序思考非常好理解，但是效率不是很好(不论数组是否有序都会执行原步骤)。实际中很少使用

2. 时间复杂度：$O(N^2)$

3. 空间复杂度：$O(1)$

4. 稳定性：不稳定

## 6. 堆排序

> 重点来咯

堆排序（heap sort）是一种基于**堆数据结构**实现的高效排序算法

堆（heap）是一种满**足特定条件的完全二叉树**，主要可分为两种类型，如图所示。

- 小顶（根）堆（min heap）：任意节点的值 ≤ 其子节点的值。
- 大顶（根）堆（max heap）：任意节点的值 ≥ 其子节点的值。

![](./assets_07/min_heap_and_max_heap.png)





而堆排序是根据堆的这种数据结构设计的一种排序，下面先来看看什么是大根堆和小根堆

性质：每个结点的值都大于其左孩子和右孩子结点的值，称之为大根堆；每个结点的值都小于其左孩子和右孩子结点的值，称之为小根堆。如下图

![image.png](排序+425a8bba-9cb1-4512-bf45-10b14d20a9fa/image 3.png)

#### 基本思想

1.首先将待排序的数组构造成一个大根堆，此时，整个数组的最大值就是堆结构的顶端

2.将根节点与末尾数交换，取出根节点（最大的值）（相当于删去根节点）

3.将剩余的n-1个数再构造成大根堆，再将顶端数与n-1位置的数交换，如此反复执行，便能得到有序数组

[https://www.bilibili.com/video/BV1aj411M71h/?spm_id_from=333.337.search-card.all.click&vd_source=3310f07bcb7152dc48cc5e65834e98b5](https://www.bilibili.com/video/BV1aj411M71h/?spm_id_from=333.337.search-card.all.click&vd_source=3310f07bcb7152dc48cc5e65834e98b5)

#### **堆排序的特性总结：**

1. 堆排序使用堆来选数，效率就高了很多。

2. 时间复杂度：$O(N*logN)$

3. 空间复杂度：$O(1)$

4. 稳定性：不稳定

## 7. 归并

一种基于分治策略的排序算法：

1. **划分阶段**：通过递归不断地将数组从中点处分开，将长数组的排序问题转换为短数组的排序问题。
2. **合并阶段**：当子数组长度为 $1$ 时终止划分，开始合并，持续地将左右两个较短的有序数组合并为一个较长的有序数组，直至结束。

![](./assets_07/merge_sort_overview.png)

#### 特性总结：

1. 归并的缺点在于需要$O(N)$的空间复杂度，归并排序的思考更多的是解决在磁盘中的外排序问题。

2. 时间复杂度：$O(N*logN)$​

   划分产生高度为 $log⁡_𝑛$ 的递归树，每层合并的总操作数量为 $𝑛$ 

3. 空间复杂度：$O(N)$

4. 稳定性：稳定（在合并过程中，相等元素的次序不交换）



