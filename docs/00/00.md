### 对 数字媒体技术 董石 老师的 数据结构课程的复习笔记

1. 本课程基本上按着 数据结构 c语言 严蔚敏版 进行课程讲解
2. @2022/12/01 根据期末复习撰写
3. @2023/09/19 根据2022届改写
4. @2024/04/10 添加了 关于[数据结构课程](https://www.bilibili.com/video/BV1Kb41127fT?p=1)(讲师——陈越、何钦铭 转自：中国大学MOOC——浙江大学频道  **BV1Kb41127fT**)的笔记和理解，添加了根据 王道 2025 数据结构复习的内容

## 参考资料

1. **电子书**

   [数据结构(C语言版)\].严蔚敏_吴伟民.扫描版.pdf](../数据结构.md ':include')

2. **笔记参考**

   [数据结构C语言严蔚敏版(第二版)超详细笔记附带课后习题*数据结构c语言版严蔚敏*别掉头发了小李的博客-CSDN博客](https://blog.csdn.net/chongyang_/article/details/109544719)

3. 课堂**ppt**

   [数据结构.zip](./assets_00/Data-Structure.zip)

4. **代码高亮网站（卡顿严重）：**

   [代码在线高亮工具 | 将高亮美化的代码一键粘贴到 Word 或 OneNote 中](https://highlightcode.com/)

5. **老师力荐（数据结构可视化网站）：**

   [Data Structure Visualization](https://www.cs.usfca.edu/~galles/visualization/Algorithms.html)

6. **cs50**

   [【哈佛】计算机科学CS50-哈佛大学*哔哩哔哩*bilibili](https://www.bilibili.com/video/BV1Rb411378V/?spm_id_from=333.337.search-card.all.click&vd_source=3310f07bcb7152dc48cc5e65834e98b5)

7. 前置知识 ： 菜鸟教程 —— 指针

   [C 指针 | 菜鸟教程](https://www.runoob.com/cprogramming/c-pointers.html)

8. `git@github.com:xiufengcheng/DATASTRUCTURE.git`

   [GitHub - xiufengcheng/DATASTRUCTURE: 数据结构](https://github.com/xiufengcheng/DATASTRUCTURE)

   ![image.png](./assets_00/image%200.png)


9. 《数据结构》课本源码与习题解析 

   `git@github.com:kangjianwei/Data-Structure.git`

   [github.com](https://github.com/kangjianwei/Data-Structure/tree/master)

10. 从来没用过

    [云课堂ppt.zip](./assets_00/云课堂ppt.zip)

# 前言

什么是数据结构？

![image.png](./assets_00/image%202.png)



## 抽象数据类型（ADT）

抽象数据类型(Abstract Data Type 简称ADT)

是指一个数学模型以及定义在此数学模型上的一组操作。抽象数据类型需要通过固有数据类型（高级编程语言中已实现的数据类型）来实现。对一个抽象数据类型进行定义时，必须给出它的名字及各运算的运算符名，即函数名，并且规定这些函数的参数性质。一旦定义了一个抽象数据类型及具体实现，程序设计中就可以像使用基本数据类型那样，十分方便地使用抽象数据类型。

## 如何理解ADT

1. 抽象数据类型 = 逻辑结构+数据运算。逻辑结构不涉及数据在计算机中具体的实现和存储，这些操作是由存储结构决定的，这就是说，抽象数据类型只需考虑问题本身即可。

2. 类型是指一类数据。基本数据类型被人做是最基本地，不可再划分的数据，一般就是整形、浮点型、以及字符型。抽象数据类型是由若干基本数据类型归并之后形成的一种新的数据类型，这种类型由用户定义，功能操作比基本数据类型更多，一般包括结构体和类。

3. 抽象数据类型是在在不涉及具体的，和计算机系统相关的细节情况下，优先理解问题本身，在此基础上，实现用计算机求解问题的过程。这就是使用抽象数据类型的目的。

## 举例

![image.png](./assets_00/image%203.png)

也就是说，ADT定义了矩阵这一数据对象，也定义了对矩阵这一数据对象的各种操作，但是

**只是抽象的定义，不会具体确定矩阵元素是什么数据类型、用什么语言实现、代码具体编写**

参考 ：

[数据结构：基本概念【详解】_https://blog.csdn.net/real_fool_/article/details/1-CSDN博客](https://blog.csdn.net/Real_Fool_/article/details/112226369)


## 1. 线性表(linear list，简称list)

    ### 定义
    
    - 线性表是n(n≥0)个相同类型的数据元素构成的**有限序列**。
    
    #### 数学表示
    
    - $(a_1，a_2，…，a_n)$ 
    
    - 其中，n为线性表的长度，当 $n=0$时，表示线性表是一个空表，即表中不包含任何元素。
    
    - 对任意一对相邻元素$<a_i,a_{i+1}>(1≤i<n)$，$a_i$称为$a_{i+1}$的**前驱 ．**$a_{i+1}$称为　$a_i$的**后继**
    
    ---
    
    #### 图示
    
    ![0.jpg](前言+++线性表+5ce939ef-97bc-496d-a45d-0afdba0adf3b/0.jpg)
    
    #### 注意事项
    
    - 线性表除第一个和最后一个元素之外，每一格数据元素只有一个前驱和一个后继
    
    - 元素含义无所谓，可以指任何东西，但**元素类型必须相同**
    
    ## 2. 顺序表
    
    #### 定义
    
    - 顺序存储结构：用一组地址连续的存储单元依次存储**数据结构**(在这里是线性表)里各个元素，这种存储结构称为线性表的顺序存储结构。
    
    - 顺序表：按照顺序存储结构存储的线性表。
    
    #### 逻辑图示
    
    ![1.jpg](前言+++线性表+5ce939ef-97bc-496d-a45d-0afdba0adf3b/1.jpg)
    
    ---
    
    #### 数学表示
    
    - 同线性表
    
    - 求址
    
        - 每个元素占用k个存储单元，则
    
        $LOC$ : 求址函数
    
        $LOC(a_i)= LOC(a_1)+(i-1)*k (1≤i ≤n)$
    
        $LOC(a_{i+1})= LOC(a_i)+k (1≤i ≤n)$
    
    #### 注意事项
    
    - 访问顺序表中任意元素的时间都相等，具有这一特点的存储结构称为**随机存取结构**。
    
    **也就是说，在顺序表中，我们访问第 $i$个元素时，不需要遍历前 $i - 1$个元素，而是可以直接访问第 $i$个元素，**
    
    比如在数组$<1，2，3，4，5，7，8，9>$中，若我们要访问 $a_4$（也就是 $5$这个元素）我们可以根据据数组首地址 $a_0$（也叫 $a[0]$）直接计算得到 $a_4$的地址，从而直接访问。

#### 随机存取结构

1. 随机存取结构是一种数据存储的方式，它允许我们在恒定的时间内访问存储器中的任意位置的数据。这种结构的特点是，数据的物理位置与访问时间无关，即可以直接访问任何数据，而不需要按顺序访问前面的数据。这与顺序存取结构形成对比，后者需要按照一定的顺序来访问数据。

2. 在随机存取结构中，数据通常存储在连续的内存地址中。例如，如果我们有一个数组，数组的每个元素都分配有一个索引，我们可以通过这个索引直接计算出元素的存储地址，从而快速访问该元素。这种存储结构使得读取和写入操作的时间复杂度为 $O(1)$，也就是说，无论数组的大小如何，访问任何一个元素所需的时间都是恒定的

3. 随机存取结构的一个典型例子就是计算机中的随机存取存储器（RAM）。RAM中的每个存储单元都可以通过一个唯一的地址来访问，这使得CPU可以快速地读取或写入数据。这种快速访问的能力对于计算机的性能至关重要，因为它允许程序快速地处理大量数据

4. 总结来说，随机存取结构提供了一种高效的数据访问方式，它在计算机科学和数据处理中非常重要，特别是在需要快速访问和修改数据的应用场景中。

### 顺序表操作

    ```C++
    [in SqList.h]
    # define LIST_INIT_SIZE 100    //(默认)最大存储容量
    typedef struct {
        ElemType  elem [LIST_INIT_SIZE];   //存储数据元素的一维数组 
        int length;                        //线性表的当前长度
    } SqList;
    ```
    
    - 初始化
    
        - 分配空间
    
        - 设置长度
    
        #### 顺序表初始化操作
    
        ```C++
        [in SqList.h]
        void InitList_Sq( SqList &L, int maxsize=LIST_INIT_SIZE, int incresize=LISTINCREMENT ) // 构造一个最大容量为maxsize的顺序表 L
        {      
             L.elem=(ElemType *)malloc(maxsize*sizeof(ElemType)); // 分配一个最大容量为maxsize的数组空间
             if(!L.elem)  exit(1);           // 存储分配失败
              L.length=0;                    // 顺序表中当前所含元素个数为 0
              L.listsize=maxsize;            // 该顺序表可以容纳maxsize个数据元素
              L.incrementsize=incresize;     // 需要时可扩容incresize个元素空间
        }// InitList_Sq
        ```
    
    - 取值
    
    - 查找
    
    - 插入
    
        - 位置是否合法
    
        - 是否满
    
        - 表长+1
    
    - 删除

![image.png](前言+++线性表+5ce939ef-97bc-496d-a45d-0afdba0adf3b/image 4.png)

## 3. 链表

    链表
    
        单链表
    
        循环链表
    
        双向链表
    
    ### 单链表
    
    - ~~链式存储结构：用一组任意的存储单元存储**数据结构**（这里是线性表)里的各元素(这组存储单元**可以是地址连续的，也可以是不连续的**)，并且每个存储元素有一个数据域，一个（或多个）指针域，数据域用来存储元素内容，指针域用来反映元素的逻辑关系(前后位置关系)，这种存储方式成为链式存储（也叫非随机存取的存储结构）。~~
    
    - 链表：按照链式存储结构存储的线性表。
    
    - 单链表：各元素只有一个指针域的链表（只含有一个指针域）
    
    示意图 ： 
    
    ![image.png](前言+++线性表+5ce939ef-97bc-496d-a45d-0afdba0adf3b/image 5.png)
    
    图中：2.3.4.5都是结构体，称之为**结点**，与顺序表不同的是，链表中的每个结点不是只单纯的存一个数据。而是一个结构体，结构体成员包括一个所存的数据，和下一个结点的地址。另外，顺序表中的地址是连续的，而链表中结点的地址是随机分配的。
    
    #### 逻辑图示(带头结点的单链表)
    
    ![2.jpg](前言+++线性表+5ce939ef-97bc-496d-a45d-0afdba0adf3b/2.jpg)
    
    - **表头指针**：存放单链表中第一个结点的地址的指针。【指向$a_0$ (带头结点时)或指向$a_1$(不带头结点时)的指针，上图中的$L$】
    
    - **头结点**：带头结点的单链表中L【上图中的a1之前的结点$a_0$】
    
    - **开始结点**：，又称首节点，存放单链表的第一个存放元素的结点。【$a_1$】
    
    - **表尾结点**：单链表中最后一个结点，表尾结点的指针域指针为空。【$a_n$】
    
    ---
    
    #### 代码表示
    
    - 同线性表
    
    - 链表的寻址 一般用$p,q$等字母表示操作性指针，例如
如果 p = &a[i]，即 a[i] = p->data（或(*p).data）
那么
$a[i]$的下一个元素的地址是： $p -> next  或（ (*p).next） $
$a[i]$的下一个元素的值是： $p->next->data$

    ---
    
    #### 注意事项
    
    - 链表的元素一般称为“结点”。
    
    - 头结点在链表中并不是必须的，仅仅是为了操作上的方便。
    
    - 结点 $a_i$ 指其数据域为 $a_i$ 的结点，而 $p$ 则是指向$ai$的指针，俗称"p结点"。
    
    - **链表有带头结点的链表和不带头结点的链表之分，带头结点的链表第一个元素为头结点$a_0$，$L$指向$a_0$; 不带头结点的链表第一个元素为头结点$a_1$，$L$指向$a_1$。**
    
    - 单链表的操作
    
    ![3.jpg](前言+++线性表+5ce939ef-97bc-496d-a45d-0afdba0adf3b/3.jpg)
    
    ### 双向链表
    
    - 双（向）链表就是每个结点中含有两个指针域的链表，其中一个指针域存放其前趋结点的地址，另一个指针域存放其后继结点的地址。
    
    #### 逻辑图示
    
    ![4.jpg](前言+++线性表+5ce939ef-97bc-496d-a45d-0afdba0adf3b/4.jpg)
    
    - **头结点**：双链表中第一个结点(上图中的$a_1$之前的结点$a_0$)
    
    - **表头指针**：存放双链表中第一个结点的地址的指针。(指向$a_0$的指针)
    
    - **开始结点**：存放双链表的第一个元素的结点。($a_1$)
    
    - **表尾结点**：双链表中最后一个结点，表尾结点的指针域指针为空。($a_n$)
    
    ---
    
    #### 数学表示
    
    - 同线性表
    
    - 寻址 一般用p,q等字母表示操作性指针，可用前驱指针域prior和后继指针域next访问表中任意节点，例如：
p = &a[i]（即a[i] = p->data）
那么
a[i]的上一个元素地址是 p -> prior , 上一个元素值是 p->prior->data
a[i]的下一个元素地址是 p -> next , 下一个元素值是 p->next->data
一般的，有
p->next-prior = p = p->prior->next

    ---
    
    #### 注意事项
    
    - 节点p的存储地址既存放在其前驱结点的后继指针域中，也存在其后继节点的前驱指针域中。因此可随意在其上向前或向后移动，使得操作更加容易。
    
    - 操作上比单链表更加便利，但存储开销增大。
    
    - 双(向)链表是非循环的，有首尾节点，注意与双向循环链表区别开来


​    

    ```C
    //－－－－－ 单链表的存储结构－－－－－
        typedef struct LNode {
            ElemType data;          //结点的数据域
            struct LNode *next;     //结点的指针域
        } LNode, *LinkList;         //LinkList 为指向结构体 LNode 的指针类型
    ```
    
    ### 链表操作
    
        - 初始化（头节点）
    
        - 取值 （挨个访问）
    
        - 查找 （挨个查找）
    
        - 插入 
    
            - 插入前驱指针指向自己
    
            - 自己指向后继
    
        - 删除 （同理）
    
    ## 4. 表创建方法
    
        - 前插法
    
            - 新节点在首位 （空节点指向表头）
    
            ![image.png](前言+++线性表+5ce939ef-97bc-496d-a45d-0afdba0adf3b/image 6.png)
    
        - 后插法
    
            - 新节点在表尾 （空节点指向表尾）
    
            ![image.png](前言+++线性表+5ce939ef-97bc-496d-a45d-0afdba0adf3b/image 7.png)

## 附页

### `typedef` 关键字

    下面是一种更简单的定义结构的方式，您可以为创建的类型取一个"别名"。例如：
    
    ```C++
    typedef struct Books
    {
       char  title[50];
       char  author[50];
       char  subject[100];
       int   book_id;
    }Books;
    ```
    
    现在，您可以直接使用 *Books* 来定义 *Books* 类型的变量，而不需要使用 struct 关键字。下面是实例：
    
    ```C++
    Books Book1, Book2;
    ```
    
    您可以使用 **typedef** 关键字来定义非结构类型，如下所示：
    
    ```C++
    typedef long int *pint32;
     
    pint32 x, y, z;
    ```
    
    x, y 和 z 都是指向长整型 long int 的指针。

### 取址运算符 `&`

- 取值运算符`&` 是用来取得其操作对象的地址。

- 如果操作对象x的类型为T，则表达式&x的类型是T类型指针（指向T类型对象 x 的指针）。

间接运算符*

- 用于当已经具有一个指针，并希望获取它所引用的对象时

（注意：千万不要解引用未初始化的指针！！！）

```C
float x, *ptr;
ptr = &x;  // 合法，使得指针ptr指向x
ptr = &(x+1);  // 错误，(x+1)不是一个左值

float x, *ptr = &x;
*ptr = 1.7;  // 将1.7赋值给变量x
++(*ptr);  // 并将变量x的值加1

```

**&运算符和*运算符有很高的优先级，结合律是从右向左。**

### 左值

左值（lvalue）是用来指明一个对象的表达式。最简单的左值就是变量名称。左值之所以称为“左”，是因为一个左值表示一个对象，它可以出现在赋值运算符的左边，例如“=”。


其他的表达式（那些能表示一个值但不指明一个对象的），就类似地称为右值（rvalue）。右值可以出现在赋值运算符的右边而不是左边的表达式。例如常量和算术表达式。

![image.png](前言+++线性表+5ce939ef-97bc-496d-a45d-0afdba0adf3b/image 8.png)

[blog.csdn.net](https://blog.csdn.net/qq_37107966/article/details/117792572?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166990156316782395353267%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=166990156316782395353267&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-117792572-null-null.142^v67^wechat_v2,201^v3^add_ask,213^v2^t3_esquery_v2&utm_term=*&spm=1018.2226.3001.4187)

![image.png](前言+++线性表+5ce939ef-97bc-496d-a45d-0afdba0adf3b/image 9.png)

[第二章习题.docx](前言+++线性表+5ce939ef-97bc-496d-a45d-0afdba0adf3b/第二章习题.docx)

[董石_线性表.docx](前言+++线性表+5ce939ef-97bc-496d-a45d-0afdba0adf3b/董石_线性表.docx)

# 附录

### RAM

**RAM** (Random Access Memory) is a crucial component in computers, providing temporary storage for data that applications need to access quickly. Let me explain what RAM does and why it’s important:

1. **What is RAM?**

    - RAM is the familiar acronym for **random access memory**. It serves as temporary storage in your computer, allowing applications to store and access data on a short-term basis.

    - Unlike your hard drive or SSD (which provide long-term storage), RAM allows data to be accessed almost instantly.

1. **What Does RAM Do?**

    - RAM enables your computer to perform everyday tasks, such as:

        - Loading applications

        - Browsing the internet

        - Editing spreadsheets

        - Running games

    - It also allows you to switch quickly among these tasks while remembering where you are in each one.

    - Think of RAM as the top of your desk: the larger your desk (more RAM), the more tasks you can work on simultaneously without digging through a filing cabinet (your storage drive).

1. **Why Is RAM Important?**

    - The speed and performance of your system directly correlate with the amount of RAM installed.

    - If your system lacks sufficient RAM, it can become slow and sluggish, especially during multitasking or when running multiple programs simultaneously.

    - Frustrations like unresponsive programs and lagging load times often result from insufficient RAM.

1. **Different Types of RAM:**

    - **DDR5**, **DDR4**, and **DDR3** are common types of computer RAM.

    - Each type has different speeds and capacities, and they are compatible with specific systems.

    - Upgrading your RAM can significantly improve your computer’s performance.

Remember that RAM is like your workspace—it allows you to handle multiple tasks efficiently. If you’re experiencing performance issues, consider upgrading your RAM to enhance your computing experience! 😊

For more details and to explore RAM options, you can visit the Crucial website. [They offer various memory modules for desktops, laptops, and Mac systems](https://www.crucial.com/articles/about-memory/support-what-does-computer-memory-do)[1](https://www.crucial.com/articles/about-memory/support-what-does-computer-memory-do)[2](https://www.crucial.com/products/memory). 🖥️💡

**RAM stands for random access memory. It is called “random access” because the technology allows the computer to temporarily store and access data immediately. Outdated methods of storing data required sequential access, which was much slower.**

